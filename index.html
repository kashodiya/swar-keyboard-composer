<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- Icon names are here: https://pictogrammers.github.io/@mdi/font/2.0.46/ -->
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@6.x/css/materialdesignicons.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vuetify/2.6.2/vuetify.css" rel="stylesheet">
    <link rel="stylesheet" href="https://webfonts.omenad.net/fonts.css">

    <script src="https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vuetify/2.6.2/vuetify.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.5.3/vue-router.min.js"></script>

    <!-- WebMidi Docs: https://webmidijs.org/docs/ -->
    <script src="https://cdn.jsdelivr.net/npm/webmidi@next/dist/iife/webmidi.iife.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/distinct-colors@3.0.0/lib/index.min.js"></script> -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/@chroma-cloud/chromajs@0.1.21/dist/chroma.umd.min.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

    <!-- For JsZip docs: https://stuk.github.io/jszip/documentation/api_zipobject/async.html -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- jsPDF docs: http://raw.githack.com/MrRio/jsPDF/master/docs/index.html     -->
    <script src="https://unpkg.com/jspdf@latest/dist/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- 
    <script type="module">
        import { openDB, deleteDB } from 'https://cdn.jsdelivr.net/npm/idb@7/+esm';
        console.log({openDB})
    </script> -->

    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/idb-keyval/6.1.0/index.min.js"></script> -->


    <!-- idb Docs: https://github.com/jakearchibald/idb -->
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>

    <style>
        .cur-swar {
            color: red;
            font-size: x-large;
        }

        .viz-container {
            /* margin-top: 200px; */
            width: 100%;
            background-color: antiquewhite;
            height: 350px;
            overflow: auto;
        }


        .keyboard-swar,
        .swar-bar {
            width: 30px;
            text-align: center;
        }

        .swar-bar {
            background-color: cornsilk;
        }

        .viz-table {
            position: relative;
            margin-left: 20px;
        }

        .swar-line-table {
            /* top: 23px; */
            top: 160px;
            z-index: 100;
        }

        .keyboard-table {
            top: 150px;
        }

        .unused-swar {
            color: lightgray;
        }

        .audio-control {
            width: 400px;
        }

        .file-name-input {
            width: 400px;
        }

        ul.swar-list>li {
            display: inline-block;
            height: 52px;
        }

        ul.swar-list {
            padding-left: 0px;
        }




        .piano-keys * {
            box-sizing: border-box
        }

        .piano-keys {
            margin: 0;
        }

        .piano-keys ul {
            height: 12em;
            /* width should be dynamically calculated*/
            /* width: 34em; */
            /* margin: 5em auto; */
            /* padding: 3em 0 0 3em; */
            padding: 1em 0 0 2em;
            position: relative;
            /* border: 1px solid #160801; */
            border-radius: 1em;
            /* background: linear-gradient(to bottom right, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0)), url(https://s3-us-west-2.amazonaws.com/s.cdpn.io/187/vwood.png); */
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5) inset, 0 1px rgba(212, 152, 125, 0.2) inset, 0 5px 15px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to bottom right, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0));
        }

        .piano-keys li {
            box-sizing: border-box;
            /* margin: 0; */
            padding: 0;
            padding-left: 5px;
            list-style: none;
            position: relative;
            float: left;
        }

        code {
            background-color: transparent !important;
            font-weight: bolder !important;
        }


        .piano-keys li>code {
            position: absolute;
            bottom: 0;
            /* background-color: transparent !important; */
            font-weight: bolder;
        }

        .piano-keys li.black>code {
            color: white;
        }

        .piano-keys li>code.not-used {
            color: grey;
        }


        .piano-keys ul .white {
            height: 9em;
            /* width: 4em; */
            width: 3em;
            z-index: 1;
            border-left: 1px solid #bbb;
            border-bottom: 1px solid #bbb;
            border-radius: 0 0 5px 5px;
            box-shadow: -1px 0 0 rgba(255, 255, 255, 0.8) inset, 0 0 5px #ccc inset, 0 0 3px rgba(0, 0, 0, 0.2);
            background: linear-gradient(to bottom, #eee 0%, #fff 100%)
        }

        .piano-keys ul .white.active-key,
        .piano-keys ul .white:active {
            border-top: 1px solid #777;
            border-left: 1px solid #999;
            border-bottom: 1px solid #999;
            box-shadow: 2px 0 3px rgba(0, 0, 0, 0.1) inset, -5px 5px 20px rgba(0, 0, 0, 0.2) inset, 0 0 3px rgba(0, 0, 0, 0.2);
            background: linear-gradient(to bottom, #fff 0%, #e9e9e9 100%);
        }

        .piano-keys .black.active-key code,
        .piano-keys .black:active code,
        .piano-keys ul .white.active-key code,
        .piano-keys ul .white:active code {
            color: red;
            padding-bottom: 8px;
        }

        .piano-keys .black {
            height: 5em;
            /* width: 2em; */
            width: 2em;
            margin: 0 0 0 -1em;
            z-index: 2;
            border: 1px solid #000;
            border-radius: 0 0 3px 3px;
            box-shadow: -1px -1px 2px rgba(255, 255, 255, 0.2) inset, 0 -5px 2px 3px rgba(0, 0, 0, 0.6) inset, 0 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(45deg, #222 0%, #555 100%)
        }

        .piano-keys .black.active-key,
        .piano-keys .black:active {
            box-shadow: -1px -1px 2px rgba(255, 255, 255, 0.2) inset, 0 -2px 2px 3px rgba(0, 0, 0, 0.6) inset, 0 1px 2px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to right, #444 0%, #222 100%);
        }

        .g,
        .a,
        .b,
        .d,
        .e {
            margin: 0 0 0 -1em;
        }

        .piano-keys ul li:first-child {
            border-radius: 5px 0 5px 5px
        }

        .piano-keys ul li:last-child {
            border-radius: 0 5px 5px 5px
        }

        .current-swar {
            color: red !important;
            font-weight: bolder !important;
        }

        .ome-class-name-radio {
            font-size: x-small !important;
        }






        ul.swar-line-vibhag {
            text-align: justify;
            padding-left: 0px;
            padding-right: 4px;
            padding-top: 5px;
            white-space: nowrap;
        }

        ul.swar-line-vibhag:after {
            content: '';
            display: inline-block;
            width: 100%;
        }

        ul.swar-line-vibhag:before {
            content: '';
            display: block;
            margin-top: -1.25em;
        }

        .swar-line-vibhag li {
            display: inline-block;
            margin-right: -.25em;
            position: relative;
            top: 1.25em;
            height: 50px;
            /* text-align: center; */
        }

        .swar-line-preview {
            border-collapse: collapse;
        }

        .swar-line-preview td {
            border: 2px solid Gray;
        }

        .swar-line-bit-symbol {
            /* font-size: larger !important; */
        }

        .swar-text-area {
            font-family: monospace, Courier, 'Courier New';
        }
    </style>
</head>

<body>

    <template id="home-template">
        <div>
            <audio id="mainAudio" ref="mainAudio" src="audio1.ogg" controls preload></audio>
            <!-- <ul>
                <li v-for="(d, i) in swarTimeData" :class="i == prevSwarIndex ? 'cur-swar' : ''">
                    {{d.swar}} - {{d.time}}
                </li>
            </ul>
            {{minSwarIndex}},
            {{maxSwarIndex}} -->
            <!-- <v-btn @click="test">Test</v-btn> -->
            <div class="viz-container">
                <table class="viz-table keyboard-table">
                    <tr>
                        <td v-for="kbSwar in keyboardLine">
                            <div :class="getClassForKeyboardSwar(kbSwar)">
                                {{kbSwar.swar}}
                            </div>
                        </td>
                    </tr>
                    <!-- <tr>
                        <td v-for="i in (maxSwarIndex - minSwarIndex) + 1">
                            <div class="swar-bar ome-bhatkhande-english">
                                {{swars[i + minSwarIndex - 1]}}
                            </div>
                        </td>
                    </tr> -->
                </table>
                <table class="viz-table swar-line-table" ref="swarLineTable">
                    <tr v-for="line in swarLines">
                        <td v-for="lineData in line">
                            <div :data-bg-color="lineData.color" :ref="'swar-bar-' + lineData.swarTimeIndex"
                                class="swar-bar ome-bhatkhande-english" :style="getSwarbarStyle(lineData)">
                                {{lineData.swar}}
                            </div>
                        </td>
                    </tr>
                </table>

                <!-- <ul> 
                    <li v-for="i in (maxSwarIndex - minSwarIndex) + 1">
                        {{swars[i + minSwarIndex - 1]}}
                    </li>
                </ul> -->

            </div>
    </template>

    <div id="app">

        <v-app>
            <v-app-bar app color="deep-purple accent-4" dark>
                <v-toolbar-title style="cursor: pointer" @click="$router.push('/')">
                    Swar Keyboard Composer
                </v-toolbar-title>
                <v-spacer></v-spacer>


                <v-btn small @click="listFiles" class="mr-3">
                    Files
                    <v-icon right>mdi-format-list-bulleted</v-icon>
                </v-btn>

                <v-btn small @click="addNewSwarEdit" class="mr-3">
                    New Swar Editor
                    <v-icon right>mdi-lead-pencil</v-icon>
                </v-btn>


                <v-btn small @click="addNewPlayer" class="mr-3">
                    New Player
                    <v-icon right>mdi-play-circle-outline</v-icon>
                </v-btn>

                <v-btn small @click="addNewRecording">
                    New Recording
                    <v-icon right>mdi-record-rec</v-icon>
                </v-btn>
            </v-app-bar>

            <v-main>
                <v-container fluid>
                    <!-- <Main></Main> -->

                    <router-view></router-view>
                </v-container>
            </v-main>

            <v-footer app>
                Kaushik Ashodiya
            </v-footer>
        </v-app>
    </div>

    <!-- </div> -->

    <template id="main-template">
        <div>

            <v-snackbar v-model="showMesssage">
                {{message}}
            </v-snackbar>

            <v-tabs show-arrows background-color="deep-purple accent-4" dark v-model="curTab" height="40">
                <v-tab v-for="(tab, tabIndex) in tabs" :key="'tab-' + tabIndex">
                    <h5>
                        {{tab.title}}
                    </h5>
                    <template v-if="tabIndex > 0">
                        <v-spacer class="ml-5"></v-spacer>
                        <v-btn x-small icon @click="closeTab(tabIndex)">
                            <v-icon>mdi-close-circle</v-icon>
                        </v-btn>
                    </template>
                </v-tab>
            </v-tabs>
            <!-- <router-view></router-view> -->

            <!-- <Main></Main> -->

            <!-- <v-tab-item v-for="tab of tabs" :key="tab.id" :value="tab.route">
                <router-view></router-view>
              </v-tab-item> -->

            <v-tabs-items v-model="curTab">
                <v-tab-item v-for="(tab, tabIndex) in tabs" :key="'tab-body-' + tabIndex">
                    <v-card class="pa-5" outlined>
                        <template v-if="tabIndex == 0">
                            <div>
                                <Welcome></Welcome>
                            </div>
                        </template>
                        <template v-else>
                            <div v-if="tab.type == 'rec'">
                                <Recorder :ref="tab.type + '-' + tabIndex" :tab-index="tabIndex"></Recorder>
                            </div>
                            <div v-if="tab.type == 'play'">
                                <Player :ref="tab.type + '-' + tabIndex" :tab-index="tabIndex" :context="tab.context">
                                </Player>
                            </div>
                            <div v-if="tab.type == 'swarEdit'">
                                <Swaredit :ref="tab.type + '-' + tabIndex" :name="tab.context.name"
                                    :swar-txt="tab.context.swarTxt" :tab-index="tabIndex"></Swaredit>
                            </div>
                        </template>
                    </v-card>
                </v-tab-item>
            </v-tabs-items>


            <!-- Dialog to show files -->
            <v-dialog v-model="showFileDialog" scrollable max-width="700px">
                <v-card>
                    <v-card-title>Files</v-card-title>
                    <v-divider></v-divider>
                    <v-card-text style="height: 500px;">



                        <v-data-table @click:row="fileTableRowClicked" disable-pagination fixed-header
                            hide-default-footer :headers="fileListHeaders" :items="filesList" sort-by="modifiedDate"
                            class="elevation-1">


                            <template v-slot:top>
                                <v-toolbar flat dense style="padding-top: 12px;">
                                    <!-- <v-toolbar-title>Filter type</v-toolbar-title>
                                    <v-divider class="mx-4" inset vertical></v-divider> -->
                                    <v-spacer></v-spacer>

                                    <!-- <v-toolbar-items> -->
                                    <v-radio-group XXv-model="row" row>
                                        <v-radio label="Recordings" value="Recordings"></v-radio>
                                        <v-radio label="Editors" value="Editors"></v-radio>
                                        <v-radio label="Players" value="Players"></v-radio>
                                    </v-radio-group>
                                    <!-- </v-toolbar-items> -->
                                </v-toolbar>
                                <v-divider class="mx-4" XXinset></v-divider>
                            </template>



                            <!-- <template v-slot:item.createdDate="{ item }">
                                {{getFormattedDate(item)}}
                            </template> -->
                            <template v-slot:item.actions="{ item }">
                                <!-- <v-icon small class="mr-2" CCclick="deleteRecord(item)">
                                    mdi-folder-open
                                </v-icon> -->



                                <v-tooltip left>
                                    <template v-slot:activator="{ on, attrs }">
                                        <v-icon small class="mr-2" @click="openRecord(item)" v-bind="attrs" v-on="on">
                                            mdi-folder-open
                                        </v-icon>
                                    </template>
                                    <span>Open</span>
                                </v-tooltip>

                                <v-tooltip right>
                                    <template v-slot:activator="{ on, attrs }">
                                        <v-icon small @click="deleteRecord(item)" v-bind="attrs" v-on="on">
                                            mdi-delete
                                        </v-icon>
                                    </template>
                                    <span>Delete</span>
                                </v-tooltip>


                            </template>
                            <template v-slot:no-data>
                                <h3>No files found. Create something new!</h3>
                                <!-- <v-btn color="primary" XXclick="initialize">
                                    Reset
                                </v-btn> -->
                            </template>

                        </v-data-table>

                    </v-card-text>
                </v-card>
            </v-dialog>

        </div>
    </template>

    <template id="welcome-template">
        <div ref="welcome-template-body" v-html="bodyHTML">
        </div>
    </template>



    <template id="recorder-template">
        <div>
            <p>
                <v-btn :disabled="!(mediaRecorderCreated && recState == 'NOT-RECORDING')" @click="startRecording">Start
                    Recording</v-btn>
                <v-btn :disabled="recState != 'RECORDING'" @click="stopRecording">Stop Recording</v-btn>
                <v-btn :disabled="recState != 'STOPPED'" @click="clearAll">Clear all</v-btn>
            </p>
            <p XXv-show="audioDataReady">
                <audio id="recordingAudio" ref="recordingAudio" controls class="audio-control"></audio>
            </p>

            <!-- {{recState}},
            deviceId = {{deviceId}},
            deviceName = {{deviceName}},
            recStartDateTime = {{recStartDateTime}} -->

            <p>
                <v-btn :disabled="!audioDataReady" @click="download">Download</v-btn>
                <v-btn :disabled="!audioDataReady" @click="openInPlayer">Open in Player</v-btn>

            </p>

            <p>
                <v-form ref="form" @submit.prevent="download">
                    <v-text-field class="file-name-input" :rules="[rules.required]" v-model="projectName"
                        label="Project name"></v-text-field>
                </v-form>
            </p>

            <ul class="swar-list">
                <li @click="swarTimeDataItemClicked(d)" v-for="d in swarTimeData">
                    <code class="ome-bhatkhande-english">{{d.swar}}</code>
                    <!-- , {{d.startTime}}, {{d.endTime}}, {{d.duration}} -->
                </li>
            </ul>


            <!-- <v-snackbar v-model="showMesssage">
                {{message}}
            </v-snackbar> -->

        </div>
    </template>


    <!-- <br>
    <ul id="keyboard">
        <li note="C" class="white">A</li>
        <li note="C#" class="black">W</li>
        <li note="D" class="white offset">S</li>
        <li note="D#" class="black">E</li>
        <li note="E" class="white offset">D</li>
        <li note="F" class="white">F</li>
        <li note="F#" class="black">T</li>
        <li note="G" class="white offset">G</li>
        <li note="G#" class="black">Y</li>
        <li note="A" class="white offset">H</li>
        <li note="A#" class="black">U</li>
        <li note="B" class="white offset">J</li>
        <li note="C2" class="white">K</li>
        <li note="C#2" class="black">O</li>
        <li note="D2" class="white offset">L</li>
        <li note="D#2" class="black">P</li>
        <li note="E2" class="white offset">;</li>
      </ul> -->

    <template id="player-template">
        <div>
            <v-file-input v-model="chosenFile" label="Upload zip file"></v-file-input>
            <audio ref="playerAudio" controls></audio>

            <p v-if="swarTimeData != null">
            <ul class="swar-list">
                <li @click="swarTimeDataItemClicked(d)" v-for="(d, index) in swarTimeData">
                    <code class="ome-bhatkhande-english" :ref="'player-swar-' + index">{{d.swar}}</code>

                </li>
            </ul>
            <v-btn @click="openFormatSwars" x-small v-if="swarTimeData != null">Format swars</v-btn>

            <v-btn @click="clearSwarHighlights" x-small>clearSwarHighlights</v-btn>

            </p>

            <!-- Credits to piano css: https://codepen.io/zastrow/pen/kxdYdk -->
            <!-- <div class="piano-keys">
                <ul class="set">


                    <li class="white f xb"></li>
                    <li class="black fs xas"></li>
                    <li class="white g xa"></li>
                    <li class="black gs xgs"></li>
                    <li class="white a xg"></li>
                    <li class="black as xfs"></li>
                    <li class="white b xf"></li>
                    <li class="white c xe"></li>
                    <li class="black cs xds"></li>
                    <li class="white d xd"></li>
                    <li class="black ds xcs"></li>
                    <li class="white e xc"></li>

                    <li class="white f xb">
                        <code class="ome-bhatkhande-english">s</code>
                    </li>
                    <li class="black fs xas">
                        <code class="ome-bhatkhande-english">R</code>
                    </li>
                    <li class="white g xa">
                        <code class="ome-bhatkhande-english">r</code>
                    </li>
                    <li class="black gs xgs">
                        <code class="ome-bhatkhande-english">G</code>
                    </li>

                </ul>
            </div> -->

            <div class="piano-keys" v-show="pianoKeysInUse.length > 0" ref="pianoKeys">
                <ul class="set">
                    <li :class="k.liClass" :data-key-index="k.keyIndex" v-for="k in pianoKeysInUse"
                        :ref="'piano-key-' + k.keyIndex">
                        <code :class="'ome-bhatkhande-english ' + (k.notUsed ? 'not-used' : '')">{{k.swar}}</code>
                    </li>
                </ul>
            </div>

            <!-- <div v-if="minSwarIndex != -1">
                minSwarIndex = {{minSwarIndex}} {{pianoKeys[minSwarIndex]}},
                maxSwarIndex = {{maxSwarIndex}} {{pianoKeys[maxSwarIndex]}}
            </div> -->


        </div>
    </template>


    <template id="swaredit-template">
        <div>
            <v-switch v-model="showGuide" label="Show guide"></v-switch>

            <div v-show="showGuide">
                <h3>Swar formatting</h3>
                <p>
                <ul>
                    <li>
                        Each aavertan on new line
                    </li>
                    <li>
                        Each vibhag seperated by a '|'' (pipe)
                    </li>
                    <li>
                        Each bit seperated by a space
                    </li>
                    <li>
                        Read guide for swar keys and other symbols <a href="https://omenad.github.io/fonts/"
                            target="_blank">here</a>
                    </li>
                </ul>
                </p>
                <p>
                <h4>Tips:</h4>
                <ul>
                    <li>
                        Use '=' (3 dots) to indicate continuation of previous bit/swar.
                    </li>
                    <li>
                        Use '-' (underscore) for empty bit/swar.
                    </li>
                </ul>
                </p>

            </div>

            <v-textarea class="mb-3 swar-text-area" hide-details outlined label="Swar lines" v-model="formattedSwars">
            </v-textarea>

            <p>
            <table class="swar-line-preview mb-3" ref="swar-line-preview-table">
                <tr v-for="(line, lineIndex) in swarLines">
                    <td v-for="(vibhag, vibhagIndex) in line">
                        <ul class="swar-line-vibhag">
                            <li v-for="(bitInfo, bitIndex) in vibhag"
                                :ref="'bit-' + lineIndex + '-' + vibhagIndex + '-' + bitIndex">
                                <code :class="bitInfo.isOmenad ? omeClassName : 'swar-line-bit-symbol'"
                                    v-html="bitInfo.symbol">
                                </code>
                            </li>
                        </ul>
                    </td>
                </tr>
            </table>
            <v-btn x-small @click="adjustBitGap(swarLineBitsGapIncrement)">Increase Gap</v-btn>
            <v-btn x-small @click="adjustBitGap(swarLineBitsGapIncrement * -1)">Decrease Gap</v-btn>

            <!-- <v-btn x-small XXclick="">Download PDF</v-btn> -->

            <!-- <v-btn x-small @click="fixSwarLineBitsWidth">Aligh bits vertically</v-btn> -->


            <!-- <v-slider class="mt-5" min="0" max="200" label="Adjust gap between bits:" v-model="swarLineBitsGap"></v-slider> -->

            </p>


            <!-- <v-btn XXclick="openFormatSwars" x-small>Download swars</v-btn> -->
            <v-btn @click="saveRecord(true)" x-small>Download zip</v-btn>

            <v-switch v-model="allowLyricsLines" label="Allow lyrics lines before swar lines"></v-switch>

            <v-divider class="mt-5 mb-5"></v-divider>

            <h4>Preview</h4>

            Use fonts/language:
            <v-radio-group row v-model="omeClassName">
                <v-radio class="ome-class-name-radio" v-for="oc in omeClassNames" :key="oc.className" :label="oc.title"
                    :value="oc.className"></v-radio>
            </v-radio-group>



            <v-divider class="mt-5 mb-5"></v-divider>



        </div>
    </template>


    <!-- Highlight is done using https://marketplace.visualstudio.com/items?itemName=zcuric.vscode-discourse-plugin -->

    <!-- <script id="worker1" type="text/discourse-plugin">
        self.onmessage = function(e) {
            console.log(e);
            self.postMessage('msg from worker ' + e.data);
        };
    </script> -->

    <script>

        let dbName = 'composer-db';
        let dbHelper;
        let db;
        let storeNames = ['Players', 'Editors', 'Recordings'];
        // let stores = {
        //     Recordings: { name: 'Recordings' },
        //     Players: { name: 'Players' },
        //     Editors: { name: 'Editors' }
        // };


        var keys = "C#3 D3 D#3 E3 F3 F#3 G3 G#3 A3 A#3 B3 C4 C#4 D4 D#4 E4 F4 F#4 G4 G#4 A4 A#4 B4 C5 C#5 D5 D#5 E5 F5 F#5 G5 G#5 A5 A#5 B5 C6".split(" ");
        var swars = "sl Rl rl Gl gl ml Ml pl Dl dl Nl nl s R r G g m M p D d N n su Ru ru Gu gu mu Mu pu Du du Nu nu".split(" ");
        var swarsEng = ".S .r .R .g .G .M .m .P .d .D .n .N S r R g G M m P d D n N S. r. R. g. G. M. m. P. d. D. n. N.".split(" ");
        let colors = ['#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#42d4f4', '#f032e6', '#bfef45', '#fabed4', '#469990', '#dcbeff', '#9A6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#a9a9a9', '#ffffff', '#000000'];
        let oneOctive = ['black cs', 'white d', 'black ds', 'white e', 'white f', 'black fs', 'white g', 'black gs', 'white a', 'black as', 'white b', 'white c'];

        // let pianoOctiveColorPattern = "W B W B W W B W B W B W".split();

        let pianoKeys = [...oneOctive, ...oneOctive, ...oneOctive];
        let tickInterval = 50;
        let tickIntervalMs = (tickInterval / 1000);
        let audioDuration = 0;
        let swarBarBgOpacify = '10';
        let prevSwarIndex = -1;
        // let swarLineTableOffsetTop = 0;         //See mounted method
        let swarTimeData = [
            { swar: 'd', timeS: 0.2, timeE: 1.2 },
            { swar: 'm', timeS: 1.2, timeE: 1.5 },
            { swar: 'g', timeS: 1.5, timeE: 2.1 },
            { swar: 'M', timeS: 2.1, timeE: 4.1 },
            { swar: 'p', timeS: 4.1, timeE: 5.5 },
            { swar: 'D', timeS: 5.5, timeE: 6.1 },
            { swar: 'n', timeS: 6.1, timeE: 6.7 },
        ];
        let swarBarHeightMultiplier = 80;
        let { minSwarIndex, maxSwarIndex } = getMinMaxSwar(swarTimeData);
        let { keyboardLine, swarLines, totalHeight } = getVizLines(swarTimeData);
        let timer = null;
        let audio = null;
        let vm = null;

        // let swarTxt = 'Used to pass text like a prop';

        // function loadServiceWorker(){
        //     var blob = new Blob([
        //         document.querySelector('#worker1').textContent
        //     ], { type: "text/javascript" })

        //     // Note: window.webkitURL.createObjectURL() in Chrome 10+.
        //     var worker = new Worker(window.URL.createObjectURL(blob));
        //     worker.onmessage = function (e) {
        //         console.log("Received: " + e.data);
        //     }
        //     worker.postMessage("hello"); // Start the worker.

        // }



        const SwarEdit = Vue.component('Swaredit', {
            template: '#swaredit-template',
            props: ['swarTxt', 'name', 'tabIndex'],
            data() {
                return {
                    showGuide: false,
                    showFormatSwars: false,
                    allowLyricsLines: true,
                    formattedSwars: '',
                    omeClassName: 'ome-bhatkhande-english',
                    swarLineBitsGapIncrement: 2,
                    swarLines: [],
                    omeClassNames: [
                        { className: 'ome-bhatkhande-english', title: 'English' },
                        { className: 'ome-bhatkhande-hindi', title: 'Hindi' },
                        { className: 'ome-bhatkhande-punjabi', title: 'Punjabi' },
                        { className: 'ome-swarlipi', title: 'Swarlipi' }
                    ],

                }
            },
            watch: {
                allowLyricsLines() {
                    this.transformFromattedSwars();
                    // formattedSwars(this.formattedSwars);
                },
                formattedSwars(newTxt) {
                    this.transformFromattedSwars();
                }
            },
            methods: {
                transformFromattedSwars() {
                    if (this.formattedSwars == null || this.formattedSwars.length == 0) return;

                    let lines = this.formattedSwars.split('\n');
                    console.log({ lines });
                    // this.lines = [];
                    // lines.forEach(line => {
                    //     let vibhags = line.split('|');

                    // });

                    lines = lines.filter(l => l.trim().length != '')

                    this.swarLines = [];
                    lines.forEach((line, lineIndex) => {
                        let vibhagList = [];
                        let vibhags = line.split('|');
                        vibhags.forEach(vibhag => {
                            let bits = vibhag.trim().split(' ').map(b => {
                                let isOmenad = true;
                                let symbol = b;
                                if (b == '=') {
                                    symbol = '~';
                                    // symbol = '&#864;';
                                    isOmenad = false;
                                } else if (b == '-') {
                                    symbol = '';
                                    isOmenad = false;
                                } else if (this.allowLyricsLines && lineIndex % 2 == 0) {
                                    isOmenad = false;
                                }
                                return { symbol, isOmenad };
                            });
                            vibhagList.push(bits);
                        });
                        this.swarLines.push(vibhagList);
                    });
                    console.log({ swarLines: this.swarLines });
                },
                // fixSwarLineBitsWidth(){
                //     this.adjustBitGap(0);                    
                // },
                adjustBitGap(amount) {
                    let maxWidth = 0;
                    this.swarLines.forEach((line, lineIndex) => {
                        line.forEach((vibhag, vibhagIndex) => {
                            vibhag.forEach((bit, bitIndex) => {
                                let refId = 'bit-' + lineIndex + '-' + vibhagIndex + '-' + bitIndex;
                                let width = this.$refs[refId][0].offsetWidth;
                                // console.log({refId, width});
                                if (width > maxWidth) maxWidth = width;
                            });
                        });
                    });

                    this.swarLines.forEach((line, lineIndex) => {
                        line.forEach((vibhag, vibhagIndex) => {
                            vibhag.forEach((bit, bitIndex) => {
                                let refId = 'bit-' + lineIndex + '-' + vibhagIndex + '-' + bitIndex;
                                this.$refs[refId][0].style.width = maxWidth + amount + 'px';
                            });
                        });
                    });

                },
                // openFormatSwars() {
                //     // this.formattedSwars = this.swarTimeData.map(d => d.swar).join(' ');
                //     // this.showFormatSwars = true;

                //     let swarTxt = this.swarTimeData.map(d => d.swar).join(' ');
                //     this.$router.app.$emit('onAddNewSwarEdit', swarTxt);

                //     // console.log({ show });
                // },
                async createPDF() {
                    let table = this.$refs['swar-line-preview-table'];
                    var doc = new jspdf.jsPDF();

                    //URLs of TTF file are in: https://webfonts.omenad.net/fonts.css


                    let fontBlob = await fetch('https://webfonts.omenad.net/webfontkit/omebhatkhandeenglish-webfont.ttf').then(r => r.blob());


                    var binaryStringToUint8Array = function (binary_string) {
                        var len = binary_string.length;
                        var bytes = new Uint8Array(len);
                        for (var i = 0; i < len; i++) {
                            bytes[i] = binary_string.charCodeAt(i);
                        }
                        return bytes;
                    };

                    const reader = new FileReader();
                    let fontBin = reader.readAsDataURL(fontBlob);
                    doc.addFileToVFS("ome_bhatkhande_english", binaryStringToUint8Array(fontBlob));
                    doc.addFont("omebhatkhandeenglish-webfont.ttf", "ome_bhatkhande_english", "normal");
                    doc.setFont("ome_bhatkhande_english");


                    // const myFont = ... // load the *.ttf font file as binary string
                    // add the font to jsPDF
                    // doc.addFileToVFS("MyFont.ttf", myFont);
                    // doc.addFont("MyFont.ttf", "MyFont", "normal");
                    // doc.setFont("MyFont");

                    doc.html(table, {
                        callback: function (doc) {
                            doc.save();
                        },
                        x: 10,
                        y: 10
                    });
                },
                saveRecord(download) {
                    let zip = new JSZip();
                    zip.file(this.name + '-formatted-swars.txt', this.formattedSwars);
                    zip.file(this.name + '-preview.html', 'TODO: THIS FILE SHOULD INCLUDE HTML OF THE TABLE');

                    zip.generateAsync({ type: "blob" }).then(async (content) => {
                        let fileName = this.name + '.zip';
                        if (download) {
                            saveAs(content, fileName);
                        }
                        //Save to db
                        // let record = { name: this.name, fileName, createdDate: new Date(), type: 'Editors', arrayBuffer: await content.arrayBuffer() };
                        let record = { name: this.name, fileName, type: 'Editors', arrayBuffer: await content.arrayBuffer() };
                        await dbHelper.saveRecord(record);
                    });

                    // zip.generateAsync({type : "string"});


                    // JSZip.loadAsync(data).then(function () {
                    // // ...
                    // });


                },
                createZip(download) {

                }
            },
            mounted() {


            },
            created() {
                console.log('SwarEdit created');


                this.formattedSwars = this.swarTxt;
                console.log({ swarTxt: this.swarTxt });

                //TODO: Remove following
                if (this.formattedSwars == '') {
                    this.formattedSwars =
                        ["- - - - | - - - - | sa da gu ru",
                            "s r g m | r g m p | g m p d",
                            "se = = = | kya = maan gu | ji na ke =",
                            "r g m p | s r g m | g m p d"].join('\n');
                }

                //If name as passed (from recorder/player), set title and save
                if (this.name && this.name.length > 0) {
                    this.$router.app.$emit('onRenameTab', { tabIndex: this.tabIndex, name: this.name });
                    // this.createZip(false);
                    this.saveRecord();
                }

            }
        })

        const Player = Vue.component('Player', {
            template: '#player-template',
            props: ['tabIndex', 'context'],
            data() {
                return {
                    tickInterval: 500,
                    // showFormatSwars: false,
                    // allowLyricsLines: false,
                    // formattedSwars: '',
                    // omeClassName: 'ome-bhatkhande-english',
                    // swarLineBitsGapIncrement: 2,
                    // swarLines: [],
                    // omeClassNames: [
                    //     { className: 'ome-bhatkhande-english', title: 'English' },
                    //     { className: 'ome-bhatkhande-hindi', title: 'Hindi' },
                    //     { className: 'ome-bhatkhande-punjabi', title: 'Punjabi' },
                    //     { className: 'ome-swarlipi', title: 'Swarlipi' }
                    // ],
                    fileName: '',
                    name: '',
                    timers: [],
                    timer: null,
                    audioDuration: 0,
                    chosenFile: null,
                    swarTimeData: null,
                    elapsedTime: 0,
                    pianoKeysInUse: [],
                    minSwarIndex: -1,
                    maxSwarIndex: -1,
                    pianoKeys, swars, keys       //These come from global vars
                }
            },
            watch: {
                // swarLineBitsGap(gap){
                //     //=
                //     // console.log(gap);
                //     //Find max width
                //     let maxWidth = 0;
                //     this.swarLines.forEach((line, lineIndex) => {
                //         line.forEach((vibhag, vibhagIndex) => {
                //             vibhag.forEach((bit, bitIndex) => {
                //                 let refId = 'bit-' + lineIndex + '-' + vibhagIndex + '-' + bitIndex;
                //                 let width = this.$refs[refId][0].offsetWidth;
                //                 // console.log({refId, width});
                //                 if(width > maxWidth) maxWidth = width;
                //             });
                //         });
                //     });

                //     this.swarLines.forEach((line, lineIndex) => {
                //         line.forEach((vibhag, vibhagIndex) => {
                //             vibhag.forEach((bit, bitIndex) => {
                //                 let refId = 'bit-' + lineIndex + '-' + vibhagIndex + '-' + bitIndex;
                //                 this.$refs[refId][0].style.width = gap + 'px';
                //             });
                //         });
                //     });


                // },

                chosenFile() {
                    console.log('File loaded');
                    this.readChosenFile();
                },
                // allowLyricsLines() {
                //     this.transformFromattedSwars();
                //     // formattedSwars(this.formattedSwars);
                // },
                // formattedSwars(newTxt) {
                //     this.transformFromattedSwars();
                // }
            },
            methods: {
                // transformFromattedSwars() {
                //     let lines = this.formattedSwars.split('\n');
                //     console.log({ lines });
                //     // this.lines = [];
                //     // lines.forEach(line => {
                //     //     let vibhags = line.split('|');

                //     // });

                //     this.swarLines = [];
                //     lines.forEach((line, lineIndex) => {
                //         let vibhagList = [];
                //         let vibhags = line.split('|');
                //         vibhags.forEach(vibhag => {
                //             let bits = vibhag.trim().split(' ').map(b => {
                //                 let isOmenad = true;
                //                 let symbol = b;
                //                 if (b == '...') {
                //                     symbol = '~';
                //                     isOmenad = false;
                //                 } else if (b == '-') {
                //                     symbol = '';
                //                     isOmenad = false;
                //                 } else if (this.allowLyricsLines && lineIndex % 2 == 0) {
                //                     isOmenad = false;
                //                 }
                //                 return { symbol, isOmenad };
                //             });
                //             vibhagList.push(bits);
                //         });
                //         this.swarLines.push(vibhagList);
                //     });
                //     console.log({ swarLines: this.swarLines });
                // },
                // // fixSwarLineBitsWidth(){
                // //     this.adjustBitGap(0);                    
                // // },
                // adjustBitGap(amount) {
                //     let maxWidth = 0;
                //     this.swarLines.forEach((line, lineIndex) => {
                //         line.forEach((vibhag, vibhagIndex) => {
                //             vibhag.forEach((bit, bitIndex) => {
                //                 let refId = 'bit-' + lineIndex + '-' + vibhagIndex + '-' + bitIndex;
                //                 let width = this.$refs[refId][0].offsetWidth;
                //                 // console.log({refId, width});
                //                 if (width > maxWidth) maxWidth = width;
                //             });
                //         });
                //     });

                //     this.swarLines.forEach((line, lineIndex) => {
                //         line.forEach((vibhag, vibhagIndex) => {
                //             vibhag.forEach((bit, bitIndex) => {
                //                 let refId = 'bit-' + lineIndex + '-' + vibhagIndex + '-' + bitIndex;
                //                 this.$refs[refId][0].style.width = maxWidth + amount + 'px';
                //             });
                //         });
                //     });

                // },
                openFormatSwars() {
                    // this.formattedSwars = this.swarTimeData.map(d => d.swar).join(' ');
                    // this.showFormatSwars = true;

                    let swarTxt = this.swarTimeData.map(d => d.swar).join(' ');
                    this.$router.app.$emit('onAddNewSwarEdit', { swarTxt, name: this.name + '-swars' });

                    // console.log({ show });
                },
                swarTimeDataItemClicked(d) {
                    // console.log({ swarData: d });
                    this.$refs['piano-key-' + d.keyIndex][0].classList.add('active-key');
                    setTimeout(() => {
                        this.$refs['piano-key-' + d.keyIndex][0].classList.remove('active-key');
                    }, d.duration);
                },
                preparePiano() {
                    //pianoKeys
                    if(this.swarTimeData.length == 0){
                        console.log('Not rendereing Piano because there are no swars in the swarTimeData');
                        return;
                    }

                    let indexes = this.swarTimeData.map(d => {
                        d.swarIndex = this.swars.indexOf(d.swar);
                        return d.swarIndex;
                    });
                    this.minSwarIndex = Math.min.apply(Math, indexes);
                    this.maxSwarIndex = Math.max.apply(Math, indexes);

                    if (this.pianoKeys[this.minSwarIndex].indexOf('black') > -1) {
                        console.log('Showing one white key to the left of the piano');
                        this.minSwarIndex--;
                    }
                    if (this.pianoKeys[this.maxSwarIndex].indexOf('black') > -1) {
                        console.log('Showing one white key to the right of the piano');
                        this.maxSwarIndex++;
                    }

                    let wKeyCount = 0;
                    let bKeyCount = 0;
                    for (let i = this.minSwarIndex; i <= this.maxSwarIndex; i++) {
                        let notUsed = this.swarTimeData.findIndex(d => d.keyIndex == i) == -1;
                        this.pianoKeysInUse.push({
                            keyIndex: i,
                            swar: this.swars[i],
                            liClass: this.pianoKeys[i],
                            notUsed
                        })
                        if (this.pianoKeys[i].indexOf('white') > -1) wKeyCount++;
                        if (this.pianoKeys[i].indexOf('black') > -1) bKeyCount++;
                    }
                    //TODO: Following 2.4 is a by trial and error, find out better way
                    let pianoWidth = (wKeyCount * 2.8) + (bKeyCount * 2);
                    console.log({ wKeyCount, bKeyCount, pianoWidth });
                    this.$refs.pianoKeys.style.width = pianoWidth + 'em';
                },
                loadZipFile(audioBlob, origFileName) {

                    JSZip.loadAsync(audioBlob).then(async (zip) => {
                        console.log({ zip });
                        for (var fileName of Object.keys(zip.files)) {
                            console.log(fileName);
                            if (fileName.indexOf('-audio.ogg') != -1) {
                                zip.file(fileName).async("ArrayBuffer").then((audioData) => {
                                    // console.log({ audioData });
                                    const blob = new Blob([audioData], { type: "audio/wav" });
                                    this.$refs.playerAudio.src = window.URL.createObjectURL(blob);
                                    console.log('Successfully got audio from zip file.')
                                })
                            } else if (fileName.indexOf('-swarTimeData.json') != -1) {
                                zip.file(fileName).async("text").then((jsonTxt) => {
                                    // console.log({ jsonTxt });
                                    this.swarTimeData = JSON.parse(jsonTxt);
                                    console.table(this.swarTimeData.map(d => { return { st: d.startTime, et: d.endTime, swar: d.swar } }));
                                    this.preparePiano();
                                    console.log('Successfully got swarTimeData from zip file.')
                                })
                            }
                        }

                        fileName = origFileName;
                        let name = fileName.replace(/\.[^/.]+$/, "");
                        // let record = { type: 'Players', name, fileName, createdDate: new Date(), arrayBuffer: ev.target.result };
                        let record = { type: 'Players', name, fileName, arrayBuffer: audioBlob };
                        await dbHelper.saveRecord(record);

                        this.fileName = fileName;
                        this.name = name;
                        this.$router.app.$emit('onRenameTab', { tabIndex: this.tabIndex, name });

                    }).catch(function (err) {
                        console.error("Failed to open ZIP file:", err);
                    })


                },
                readChosenFile() {
                    if (!this.chosenFile) {
                        this.data = "No File Chosen";
                        //TODO: Show this err to user?
                        return;
                    };
                    var reader = new FileReader();
                    reader.onload = (ev) => {
                        JSZip.loadAsync(ev.target.result).then(async (zip) => {
                            console.log({ zip });
                            for (var fileName of Object.keys(zip.files)) {
                                console.log(fileName);
                                if (fileName.indexOf('-audio.ogg') != -1) {
                                    zip.file(fileName).async("ArrayBuffer").then((audioData) => {
                                        // console.log({ audioData });
                                        const blob = new Blob([audioData], { type: "audio/wav" });
                                        this.$refs.playerAudio.src = window.URL.createObjectURL(blob);
                                        console.log('Successfully got audio from zip file.')
                                    })
                                } else if (fileName.indexOf('-swarTimeData.json') != -1) {
                                    zip.file(fileName).async("text").then((jsonTxt) => {
                                        // console.log({ jsonTxt });
                                        this.swarTimeData = JSON.parse(jsonTxt);
                                        console.table(this.swarTimeData.map(d => { return { st: d.startTime, et: d.endTime, swar: d.swar } }));
                                        this.preparePiano();
                                        console.log('Successfully got swarTimeData from zip file.')
                                    })
                                }
                            }

                            fileName = this.chosenFile.name;
                            let name = fileName.replace(/\.[^/.]+$/, "");
                            // let record = { type: 'Players', name, fileName, createdDate: new Date(), arrayBuffer: ev.target.result };
                            let record = { type: 'Players', name, fileName, arrayBuffer: ev.target.result };
                            await dbHelper.saveRecord(record);

                            this.fileName = this.chosenFile.name;
                            this.name = name;
                            this.$router.app.$emit('onRenameTab', { tabIndex: this.tabIndex, name });

                        }).catch(function (err) {
                            console.error("Failed to open ZIP file:", err);
                        })
                    };
                    reader.onerror = function (err) {
                        console.error("Failed to read file", err);
                    }

                    const arrayBuffer = reader.readAsArrayBuffer(this.chosenFile);
                },
                clearSwarHighlights() {
                    this.swarTimeData.forEach((d, i) => {
                        d.visited = false;
                        this.$refs['player-swar-' + i][0].classList.remove('current-swar');
                    });
                },
                clearAllTimers() {
                    this.timers.forEach(t => {
                        clearTimeout(t);
                    });
                },
                audioPlaying() {
                    console.log('onPlaying...');

                    this.clearAllTimers();

                    //Create setTimeout for each bit
                    this.timers = [];
                    // let triggerTime = 0;
                    this.clearSwarHighlights();
                    let audioPlayerTime = this.$refs.playerAudio.currentTime * 1000;
                    console.log({ audioPlayerTime });
                    this.swarTimeData.forEach((d, index) => {
                        if (d.startTime < audioPlayerTime) {
                            console.log({ s: 'SKIPP', index, swar: d.swar, dur: d.duration });
                            return;
                        };

                        let triggerTime = d.startTime - audioPlayerTime;
                        // triggerTime += d.startTime;
                        let timer = setTimeout((() => {
                            //Set swarTimeDataItem as memory for setTimeout callback
                            let swarTimeDataItem = d;
                            return () => {
                                console.log({ index, swar: d.swar, dur: d.duration, triggerTime });

                                let keyIndex = swarTimeDataItem.keyIndex;
                                let duration = swarTimeDataItem.duration;
                                this.$refs['piano-key-' + keyIndex][0].classList.add('active-key');
                                setTimeout(() => {
                                    this.$refs['piano-key-' + keyIndex][0].classList.remove('active-key');
                                }, d.duration);

                                this.$refs['player-swar-' + index][0].classList.add('current-swar');
                                // swarTimeDataItem.visited = true;
                            }
                        })(), triggerTime);
                        this.timers.push(timer);
                    });
                },
                XXaudioPlaying() {
                    console.log('onPlaying...');
                    this.elapsedTime = 0;
                    this.clearSwarHighlights();
                    this.timer = setInterval(this.onTick, this.tickInterval);
                    // this.startAnim();
                },
                audioPaused() {
                    console.log('audioPaused...');
                    this.clearAllTimers();
                    clearInterval(this.timer);
                    // this.stopAnim();
                },
                audioEnded() {
                    console.log('audioEnded...');
                    clearInterval(this.timer);
                    // this.stopAnim();
                    this.prevSwarIndex = -1;
                },
                audioSeeking(e) {
                    // console.log('audioSeeking...', this.$refs.playerAudio.currentTime);
                    // this.onTick();
                },
                onTick() {
                    // let curTime = this.$refs.playerAudio.currentTime * 1000;
                    this.elapsedTime += this.tickInterval;

                    let curTime = this.elapsedTime;



                    //TODO: Note that for fast keys you need to find more then one index
                    //  Remember the last index animated
                    //  Find current index
                    //  Highlight all the keys between previous and current index, and animate last one.
                    //  Do not do anything if both are same!

                    let index = this.swarTimeData.findIndex(d => curTime >= d.startTime && curTime <= d.endTime);



                    // console.log({index, lastSwarDataIndexVisited: this.lastSwarDataIndexVisited});

                    if (index == -1 || (index > -1 && this.swarTimeData[index].visited)) {
                        console.log({ index, curTime });
                        if (index > -1 && this.swarTimeData[index].visited) {
                            console.log({ visited: this.swarTimeData[index].visited });
                        }
                    } else {
                        // console.log(curTime, index);

                        let keyIndex = this.swarTimeData[index].keyIndex;
                        let duration = this.swarTimeData[index].duration;
                        this.$refs['piano-key-' + keyIndex][0].classList.add('active-key');

                        setTimeout(() => {
                            this.$refs['piano-key-' + keyIndex][0].classList.remove('active-key');
                        }, duration);

                        // setTimeout(() => {
                        //     let makeTickCallback = () => {
                        //         let pianoKeyEle = this.$refs['piano-key-' + keyIndex][0];
                        //         return () => {
                        //             pianoKeyEle.classList.remove('active-key');
                        //        }
                        //     }
                        //     this.$nextTick(makeTickCallback());
                        // }, duration);

                        for (let i = 0; i <= index; i++) {
                            if (!this.swarTimeData[i].visited) {
                                console.log('current-swar ', { i, index });
                                this.$refs['player-swar-' + i][0].classList.add('current-swar');
                                this.swarTimeData[i].visited = true;
                            }
                        }
                        // this.$refs['player-swar-' + index][0].classList.add('current-swar');

                    }
                },
                // async createPDF() {
                //     let table = this.$refs['swar-line-preview-table'];
                //     var doc = new jspdf.jsPDF();

                //     //URLs of TTF file are in: https://webfonts.omenad.net/fonts.css


                //     let fontBlob = await fetch('https://webfonts.omenad.net/webfontkit/omebhatkhandeenglish-webfont.ttf').then(r => r.blob());


                //     var binaryStringToUint8Array = function (binary_string) {
                //         var len = binary_string.length;
                //         var bytes = new Uint8Array(len);
                //         for (var i = 0; i < len; i++) {
                //             bytes[i] = binary_string.charCodeAt(i);
                //         }
                //         return bytes;
                //     };

                //     const reader = new FileReader();
                //     let fontBin = reader.readAsDataURL(fontBlob);
                //     doc.addFileToVFS("ome_bhatkhande_english", binaryStringToUint8Array(fontBlob));
                //     doc.addFont("omebhatkhandeenglish-webfont.ttf", "ome_bhatkhande_english", "normal");
                //     doc.setFont("ome_bhatkhande_english");


                //     // const myFont = ... // load the *.ttf font file as binary string
                //     // add the font to jsPDF
                //     // doc.addFileToVFS("MyFont.ttf", myFont);
                //     // doc.addFont("MyFont.ttf", "MyFont", "normal");
                //     // doc.setFont("MyFont");

                //     doc.html(table, {
                //         callback: function (doc) {
                //             doc.save();
                //         },
                //         x: 10,
                //         y: 10
                //     });
                // }
            },
            mounted() {
                let audio = this.$refs.playerAudio;
                // audio.currentTime = 24 * 60 * 60;
                // audio.addEventListener('timeupdate', setDuration = () => {
                //     this.audioDuration = this.audio.duration;
                //     console.log('duration=', this.audio.duration);
                //     this.audio.currentTime = 0;
                //     this.audio.removeEventListener('timeupdate', setDuration)
                // })
                audio.addEventListener('playing', this.audioPlaying);
                audio.addEventListener('pause', this.audioPaused);
                audio.addEventListener('ended', this.audioEnded);
                audio.addEventListener('seeking', this.audioSeeking);

                //TODO: Remove following
                // this.showFormatSwars = true;
                // this.formattedSwars =
                //     ["- - - - | - - - - | sa da gu ru",
                //         "s r g m | r g m p | g m p d",
                //         "se ... ... ... | kya ... maan gu | ji na ke ...",
                //         "r g m p | s r g m | g m p d"].join('\n');


                                
                if (this.context != null) {
                    console.log('Got context = ');
                    console.log(this.context);
                    this.loadZipFile(this.context.audioBlob, this.context.fileName);
                } else {
                    console.log('NO context');
                }

            },
            created() {
                console.log('Player created');



            }
        })



        const Recorder = Vue.component('Recorder', {
            template: '#recorder-template',
            props: ['tabIndex'],
            data() {
                return {
                    audioDataReady: false,
                    rules: {
                        required: value => !!value || 'Please enter download file name.'
                    },
                    recState: 'NOT-RECORDING',
                    // showMesssage: false,
                    // message: '',
                    deviceId: '',
                    deviceName: '',
                    mediaRecorderCreated: false,
                    recStartDateTime: null,
                    swarTimeData: [],
                    oldProjectName: '',
                    projectName: '',
                    pianoKeyDownInfo: null,
                    keys, swars, swarsEng            //These come from global vars
                }
            },
            methods: {
                async openInPlayer() {
                    let name = this.getFileName();
                    if (!name) return;
                    let audioBlob = await this.getZipBlob();
                    let fileName = name + '.zip';
                    this.$router.app.$emit('onAddNewPlayer', { audioBlob, name, fileName });
                },
                generateProjectName() {
                    const date = new Date();
                    var fileName = date.getFullYear() + '-'
                        + ('0' + (date.getMonth() + 1)).slice(-2) + '-'
                        + ('0' + date.getDate()).slice(-2) + '-'
                        + ('0' + date.getHours()).slice(-2) + '-'
                        + ('0' + date.getMinutes()).slice(-2) + '-'
                        + ('0' + date.getSeconds()).slice(-2);
                    return fileName;
                },
                getFileName() {
                    this.$refs.form.validate();
                    if (this.projectName == '') {
                        // this.message = "Please enter file name";
                        // this.showMesssage = true;
                        this.$router.app.$emit('onShowMessage', 'Please enter file name');
                        return false;
                    }
                    return this.projectName;
                },
                async download() {
                    let name = this.getFileName();
                    if (!name) return;
                    let content = await this.getZipBlob();
                    let fileName = name + '.zip';
                    saveAs(content, fileName);
                    await this.saveRecord();
                    this.oldProjectName = name;
                },
                async getZipBlob() {
                    let swarList = this.swarTimeData.map(d => d.swar);
                    let swarEngList = this.swarTimeData.map(d => this.swarsEng[d.keyIndex]);
                    let plainSwarTimeData = this.swarTimeData.map(d => {
                        let { duration, startTime, endTime, keyIndex, swar } = d;
                        return { duration, startTime, endTime, keyIndex, swar };
                    });

                    let zip = this.$options.zip;
                    zip.file(this.projectName + '-swarTimeData.json', JSON.stringify(plainSwarTimeData));
                    zip.file(this.projectName + '-omenad-swars.txt', swarList.join(' '));
                    zip.file(this.projectName + '-eng-swars.txt', swarEngList.join(' '));
                    zip.file(this.projectName + '-audio.ogg', this.$options.audioBlob, { base64: true });

                    let content = await zip.generateAsync({ type: "blob" });
                    return content;
                },
                clearAll() {
                    this.$options.zip = new JSZip();
                    this.$options.chunks = [];
                    this.$refs.recordingAudio.src = '';
                    this.swarTimeData = [];
                    this.audioDataReady = false;
                    this.recState = 'NOT-RECORDING';
                    this.recStartDateTime = null;
                    this.projectName = this.generateProjectName();
                    this.oldProjectName = '';
                },
                swarTimeDataItemClicked(d) {
                    console.log({ swarTimeDataItem: d });
                    // console.table(this.swarTimeData);
                },
                async stopRecording() {
                    let mediaRecorder = this.$options.mediaRecorder;
                    mediaRecorder.stop();
                    this.recState = 'STOPPED';
                    this.calculateSwarTimes();

                    console.table(this.swarTimeData.map(d => { return { st: d.startTime, et: d.endTime, swar: d.swar } }));


                    // let name = this.getFileName();
                    // if(!name) return;
                    // let blob = await this.getZipBlob();
                    // let fileName = name + '.zip';
                    // let arrayBuffer = await blob.arrayBuffer();
                    // let record = {type: 'Recordings', name, fileName, arrayBuffer};
                    // if(this.oldProjectName.length > 0 && fileName != this.oldProjectName){
                    //     //Update record
                    //     let oldKey = this.oldProjectName.replace(/\.[^/.]+$/, "");
                    //     await dbHelper.saveRecord(record, oldKey);
                    // }else{
                    //     //Insert record
                    //     await dbHelper.saveRecord(record);
                    // }
                    // this.$router.app.$emit('onShowMessage', `Recording data is saved under file name: ${fileName}`);
                    // this.oldProjectName = this.projectFileName;

                    await this.saveRecord();

                },
                async saveRecord() {
                    let name = this.getFileName();
                    if (!name) return;
                    let blob = await this.getZipBlob();
                    let fileName = name + '.zip';
                    let arrayBuffer = await blob.arrayBuffer();
                    let record = { type: 'Recordings', name, fileName, arrayBuffer };
                    if (this.oldProjectName.length > 0 && name != this.oldProjectName) {
                        //Update record
                        let oldKey = this.oldProjectName;
                        await dbHelper.saveRecord(record, oldKey);
                    } else {
                        //Insert record
                        await dbHelper.saveRecord(record);
                    }
                    this.$router.app.$emit('onShowMessage', `Recording data is saved under file name: ${fileName}`);
                    this.oldProjectName = name;

                    this.$router.app.$emit('onRenameTab', { tabIndex: this.tabIndex, name });

                },
                startRecording() {
                    let chunks = this.$options.chunks;
                    let mediaRecorder = this.$options.mediaRecorder;
                    console.log('Using Media Recorder: ', mediaRecorder);
                    // let recordingAudio = document.getElementById('recordingAudio');
                    let recordingAudio = this.$refs.recordingAudio;
                    console.log('Starting recording...for 4 sec...');
                    mediaRecorder.start();
                    this.recState = 'RECORDING';
                    this.recStartDateTime = new Date();

                    // setTimeout(() => {
                    //     console.log('Stopping recording...');
                    //     mediaRecorder.stop();
                    // }, 4000);

                    mediaRecorder.onstop = async (e) => {
                        let chunks = this.$options.chunks;
                        const blob = new Blob(chunks, { 'type': 'audio/ogg; codecs=opus' });
                        this.$options.audioBlob = blob;
                        chunks = [];
                        const audioURL = window.URL.createObjectURL(blob);
                        recordingAudio.src = audioURL;
                        this.audioDataReady = true;
                    }
                    mediaRecorder.ondataavailable = function (e) {
                        console.log('Getting chunks...')
                        chunks.push(e.data);
                    }
                },
                calculateSwarTimes() {
                    //Take recStartDateTime and iterate swarTimeData to set time and duration
                    this.swarTimeData.forEach(d => {
                        // debugger;
                        d.startTime = d.startDateTime - this.recStartDateTime;
                        d.duration = d.endDateTime - d.startDateTime;
                        d.endTime = d.startTime + d.duration;
                        // return {startTime, duration, swar: d.swar, keyIndex: d.keyIndex}
                        // return {...d, startTime, duration}
                    });
                    // console.log(this.swarTimeData);
                },
                onMidiEnabled() {
                    if (WebMidi.inputs.length < 1) {
                        console.log('No MIDI device detected.');
                        //TODO: Show this error
                        // document.body.innerHTML += "No device detected.";
                    } else {
                        WebMidi.inputs.forEach((device, index) => {
                            this.deviceId = index;
                            this.deviceName = device.name;
                        });
                    }

                    const mySynth = WebMidi.inputs[0];
                    // const mySynth = WebMidi.getInputByName("TYPE NAME HERE!")

                    mySynth.channels[1].addListener("noteoff", e => {
                        if (this.recState != 'RECORDING') return;
                        console.log('noteoff', e.note.number);
                        let keyIndex = this.keys.indexOf(e.note.identifier);
                        if (keyIndex != -1) {
                            // let lastIndex = this.swarTimeData.length - 1; 
                            // this.swarTimeData[lastIndex].endDateTime = new Date();

                            // let relatedNoteonData = this.swarTimeData.find(d => d.keyIndex == keyIndex);

                            let relatedNoteonData;
                            //We should iterate from the last element to fist one in swarTimeData
                            for (let i = this.swarTimeData.length - 1; i >= 0; i--) {
                                if (this.swarTimeData[i].keyIndex == keyIndex) {
                                    relatedNoteonData = this.swarTimeData[i];
                                    break;
                                }
                            }

                            if (relatedNoteonData) {
                                relatedNoteonData.endDateTime = new Date();
                            } else {
                                console.log('WAT!', keyIndex);
                            }



                            // ({
                            //     duration: 0, startTime: 0, endTime: 0,     //Calcualted in the calculateSwarTimes()
                            //     keyIndex,
                            //     swar: swars[keyIndex],
                            //     endDateTime: new Date(),
                            //     startDateTime: this.pianoKeyDownInfo.dateTime
                            // });
                            // console.log(this.swarTimeData[lastIndex]);
                        } else {
                            //2 or more keys were pressed together so missed noteoff of previous key
                            console.log('WAT! keyIndex = -1, e.note.identifier = ' + e.note.identifier);
                        }
                    });

                    mySynth.channels[1].addListener("noteon", e => {
                        if (this.recState != 'RECORDING') return;
                        console.log('noteon', e.note.number)
                        // this.pianoKeyDownInfo = {
                        //     keyEvent: e,
                        //     dateTime: new Date()
                        // };

                        let keyIndex = this.keys.indexOf(e.note.identifier);
                        if (keyIndex != -1) {
                            this.swarTimeData.push({
                                duration: 0, startTime: 0, endTime: 0,     //Calcualted in the calculateSwarTimes()
                                keyIndex,
                                swar: swars[keyIndex],
                                // endDateTime:                             This will be set in noteoff event
                                startDateTime: new Date()
                            });
                        } else {
                            console.log('Only keys from mandra, madhaya and taar saptak is recorded.');
                        }
                    });

                    this.$options.mySynth = mySynth;

                },


            },
            created() {
                console.log('Recorder created');

                this.$options.chunks = [];
                this.$options.zip = new JSZip();
                const constraints = { audio: true };
                navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                    this.$options.mediaRecorder = new MediaRecorder(stream);
                    this.mediaRecorderCreated = true;
                    console.log('Media Recorder created');
                }, () => {
                    console.log('Error getting: navigator.mediaDevices.getUserMedia');
                });
                this.projectName = this.generateProjectName();


                WebMidi.enable().then(this.onMidiEnabled).catch(err => {
                    //TODO: Show this error
                    //this.$options.deviceName = err;
                }, true);

            },
            beforeDestroy() {
                console.log('Recorder beforeDestroy');
                this.$options.mySynth.removeListener();
            }
        })


        const Main = Vue.component('Main', {
            template: '#main-template',
            data: () => {
                return {
                    showMesssage: false,
                    message: '',
                    curTab: null,
                    tabTitleIndex: 1,
                    showFileDialog: false,
                    tabs: [
                        {
                            title: 'Welcome',
                            type: 'welcome'
                        }
                        // , {
                        //     title: 'Rec-1',
                        //     type: 'rec'
                        // }, {
                        //     title: 'Play-1',
                        //     type: 'play'
                        // }
                    ],
                    // files: {
                    //     'Recordings': [
                    //         { name: 'Rec-1', createdDate: new Date, modifiedDate: new Date() }
                    //     ],
                    //     'Players': [
                    //         { name: 'Play-1', createdDate: new Date, modifiedDate: new Date() }
                    //     ],
                    //     'Editors': [
                    //         { name: 'Edit-1', createdDate: new Date, modifiedDate: new Date() }
                    //     ],
                    // },
                    filesList: [],       //See createFilesList() from created()
                    fileListHeaders: [
                        { text: 'Type', value: 'type' },
                        { text: 'Name', value: 'name' },
                        { text: 'Created Date', value: 'createdDateStr' },
                        // { text: 'Modified Date', value: 'modifiedDate' },
                        { text: 'Actions', value: 'actions', sortable: false },
                    ],
                }
            },
            methods: {
                fileTableRowClicked(row) {
                    console.log({ row });
                },
                async loadFilesListFromDB() {
                    this.filesList = [];

                    // let rawData = await dbHelper.getAllPlayerData();
                    // let playerData = rawData.map(d => {
                    //     return { type: 'Players', ...d, actions: 0, createdDate: getFormattedDate(d.createdDate) }
                    // });


                    let rawData = await dbHelper.getAllData();
                    rawData.forEach(d => {
                        d.actions = 0;
                        d.createdDateStr = getFormattedDate(d.createdDate);
                    });

                    this.filesList.push(...rawData);
                    // console.log({ filesList: this.filesList });
                },
                addNewPlayer(context) {
                    console.log('addNewPlayer called');
                    this.tabTitleIndex++;
                    let title = 'Play-' + this.tabTitleIndex;
                    if (context && context.name) title = context.name;
                    this.tabs.push({ title, type: 'play', context });
                    this.curTab = this.tabs.length - 1;
                },
                addNewRecording() {
                    console.log('addNewRecording called');
                    this.tabTitleIndex++;
                    let title = 'Rec-' + this.tabTitleIndex;
                    // if(context && context.name) title = context.name;
                    this.tabs.push({ title, type: 'rec' });
                    this.curTab = this.tabs.length - 1;
                },
                addNewSwarEdit(context) {
                    console.log('addNewSwarEdit called: ', { context });
                    let title = 'SEdit-' + this.tabTitleIndex;
                    if (!context) {
                        context = { name: title }
                    }
                    this.tabTitleIndex++;
                    this.tabs.push({ title, type: 'swarEdit', context });
                    this.curTab = this.tabs.length - 1;
                },
                listFiles() {
                    this.loadFilesListFromDB();
                    this.showFileDialog = true;
                },
                renameTab(info) {
                    console.log({ info });
                    this.tabs[info.tabIndex].title = info.name;
                },
                closeTab(tabIndex) {
                    let refId = this.tabs[tabIndex].type + '-' + tabIndex;
                    // console.log('Closing refid = ' + refId);
                    let component = this.$refs[refId];
                    // console.log(component[0]);
                    component[0].$destroy();

                    this.tabs.splice(tabIndex, 1);
                    console.log('closeTab called...');
                },
                async deleteRecord(record) {
                    await dbHelper.deleteRecord(record);
                    console.log('Deleted...', { record });
                    this.loadFilesListFromDB();
                },
                openRecord(record) {
                    console.log('Opening...', { record });
                    if (record.type == 'Editors') {
                        this.addNewSwarEdit();
                        this.showFileDialog = false;
                    }
                },
                openShowMessage(msg) {
                    this.message = msg;
                    this.showMesssage = true;
                }
            },
            mounted() {
                this.curTab = 0;
            },
            created() {
                this.loadFilesListFromDB();

                // this.createFilesList();

                this.$router.app.$on('onAddNewRecording', this.addNewRecording);
                this.$router.app.$on('onAddNewPlayer', this.addNewPlayer);
                this.$router.app.$on('onAddNewSwarEdit', this.addNewSwarEdit);
                this.$router.app.$on('onListFiles', this.listFiles);
                this.$router.app.$on('onRenameTab', this.renameTab);
                this.$router.app.$on('onShowMessage', this.openShowMessage);


                console.log('Main created');
            }
        })

        const Home = Vue.component('Home', {
            template: '#home-template',
            data: () => {
                return {
                    audio, swarTimeData, prevSwarIndex, timer, tickInterval, tickIntervalMs,
                    minSwarIndex, maxSwarIndex, swars, keyboardLine, swarLines, colors, audioDuration,
                    totalHeight, swarBarBgOpacify
                }
            },
            methods: {
                test() {
                    this.swarTimeData.forEach((d, di) => {
                        let curSwarBar = this.$refs['swar-bar-' + di][0];
                        let color = curSwarBar.dataset['bgColor'];
                        curSwarBar.style.backgroundColor = color + 'F5';
                        console.log(curSwarBar.style.backgroundColor, curSwarBar.dataset['bgColor']);
                    });

                },
                highlightSwarBar(swarTimeIndex) {
                    this.swarTimeData.forEach((d, di) => {
                        let curSwarBar = this.$refs['swar-bar-' + di][0];
                        let color = curSwarBar.dataset['bgColor'];
                        if (di == swarTimeIndex) {
                            color += 'F5';
                        } else {
                            color += this.swarBarBgOpacify;
                        }
                        // console.log(di, swarTimeIndex, color);
                        curSwarBar.style.backgroundColor = color;
                    });
                },
                onTick() {
                    let curTime = this.audio.currentTime;
                    let index = this.swarTimeData.findIndex(d => curTime >= d.timeS && curTime <= d.timeE);
                    // console.log(curTime, index);
                    if (index != -1 && index != this.prevSwarIndex) {
                        // console.log(this.swarTimeData[index], curTime, this.swarTimeData[index].time - curTime);
                        this.prevSwarIndex = index;
                        this.highlightSwarBar(index);
                        let curSwarBar = this.$refs['swar-bar-' + index][0];
                        // console.log({curSwarBar}, curSwarBar.dataset['bgColor']);
                        curSwarBar.style.backgroundColor = curSwarBar.dataset['bgColor'] + 'F5';
                    }
                },
                stopAnim() {
                    console.log('stoping naim...');
                },
                startAnim() {
                    let swarLineTable = this.$refs.swarLineTable;

                    // swarLineTable.offsetTop = this.swarLineTableOffsetTop;

                    console.log('starting naim...', this.swarLineTableOffsetTop);
                    console.log({ totalHeight: this.totalHeight, audioDuration: this.audioDuration });
                    const animation = gsap.timeline();


                    this.swarTimeData.forEach((d, di) => {
                        let curSwarBar = this.$refs['swar-bar-' + di][0];
                        let color = curSwarBar.dataset['bgColor'];
                        curSwarBar.style.backgroundColor = color + this.swarBarBgOpacify;
                    });


                    animation.set(swarLineTable, { y: 0 }).to(swarLineTable, { y: this.totalHeight * -1, ease: "linear", duration: this.audioDuration })
                },
                audioPlaying() {
                    console.log('onPlaying...');
                    this.timer = setInterval(this.onTick, this.tickInterval);
                    this.startAnim();
                },
                audioPaused() {
                    console.log('audioPaused...');
                    clearInterval(this.timer);
                    this.stopAnim();
                },
                audioEnded() {
                    console.log('audioEnded...');
                    clearInterval(this.timer);
                    this.stopAnim();
                    this.prevSwarIndex = -1;
                },
                audioSeeking(e) {
                    // console.log('audioSeeking...', this.audio.currentTime);
                    // this.onTick();
                },
                // audioLoadedData(e) {
                //     console.log(this.audio.duration)
                // },
                getClassForKeyboardSwar(kbSwar) {
                    let classNames = 'keyboard-swar ome-bhatkhande-english';
                    if (!kbSwar.swarIsUsed) classNames += ' unused-swar';
                    return classNames;
                },
                getSwarbarStyle(lineData) {
                    let style = '';
                    if (lineData.swar != null) {
                        //Opacity suffix to hash colors: 00, 01, 99, 9D, 1D, CC, E4, F5
                        style = 'height: ' + lineData.height + 'px; background-color: ' + lineData.color + this.swarBarBgOpacify + ';'
                    }
                    return style;
                }
            },
            mounted() {
                this.audio = this.$refs['mainAudio'];
                this.audio.currentTime = 24 * 60 * 60;
                // console.log(this.audio);
                this.audio.addEventListener('timeupdate', setDuration = () => {
                    this.audioDuration = this.audio.duration;
                    console.log('duration=', this.audio.duration);
                    this.audio.currentTime = 0;
                    this.audio.removeEventListener('timeupdate', setDuration)
                })
                this.audio.addEventListener('playing', this.audioPlaying);
                this.audio.addEventListener('pause', this.audioPaused);
                this.audio.addEventListener('ended', this.audioEnded);
                this.audio.addEventListener('seeking', this.audioSeeking);
                // this.audio.addEventListener('loadeddata', this.audioLoadedData);

                // this.audio.addEventListener("durationchange", function (e) {
                //     if (this.duration != Infinity) {
                //         var duration = this.duration
                //         _player.remove();
                //         next(duration);
                //     };
                // }, false);

                let swarLineTable = this.$refs.swarLineTable;
                // this.swarLineTableOffsetTop = swarLineTable.offsetTop;
                console.log(swarLineTable);


            }
        })

        function getMinMaxSwar(swarTimeData) {
            //This funciton also adds swarIndex to each swarTimeData
            let indexes = swarTimeData.map(d => {
                d.swarIndex = swars.indexOf(d.swar);
                return d.swarIndex;
            });
            // console.log(indexes);
            return { minSwarIndex: Math.min.apply(Math, indexes), maxSwarIndex: Math.max.apply(Math, indexes) };
        }

        function getVizLines(swarTimeData) {

            let keyboardLine = [];
            for (let i = minSwarIndex; i <= maxSwarIndex; i++) {
                let swarIsUsed = swarTimeData.findIndex(d => d.swar == swars[i]) == -1 ? false : true;
                keyboardLine.push({
                    swar: swars[i], swarIsUsed
                });
                // console.log({ swarIsUsed })
            }

            let swarLines = [];
            let totalHeight = 0;
            swarTimeData.forEach((d, di) => {
                let swarData = [];
                for (let i = minSwarIndex; i <= maxSwarIndex; i++) {
                    let swar = null;
                    let height = 0;
                    let color = '';
                    let swarTimeIndex = -1;
                    if (i == d.swarIndex) {
                        swar = d.swar;
                        height = (d.timeE - d.timeS) * swarBarHeightMultiplier;
                        color = getColorOfSwar(swar);
                        totalHeight += height - 0.5;
                        swarTimeIndex = di;
                    }
                    swarData.push({
                        swar, height, color, totalHeight, swarTimeIndex
                    })
                }
                swarLines.push(swarData);
            });
            // console.log({ keyboardLine, swarLines });
            // console.log({ totalHeight });
            return { keyboardLine, swarLines, totalHeight };
        }

        function getColorOfSwar(swar) {
            let index = swars.indexOf(swar);
            let colorIndex = index - minSwarIndex;
            return colors[colorIndex];
        }


        const Welcome = Vue.component('Welcome', {
            template: '#welcome-template',
            data() {
                return {
                    bodyHTML: 'Loading...'
                }
            },
            methods: {
            },
            async mounted() {
                // setTimeout(() => {
                //     this.bodyHTML = marked.parse('# Marked in the browser\n\nRendered by **marked**.');
                // }, 2000);
                let welcomeMDtxt = await fetch('README.md').then(res => res.text());
                console.log(welcomeMDtxt);
                this.bodyHTML = marked.parse(welcomeMDtxt);
            },
            created() {
                console.log('Welcome created');
            }
        })




        // const Bar = Vue.component('Bar-Page', {
        //     template: '#bar-template',
        //     data() {
        //         return {
        //             state: store.state
        //         }
        //     },
        //     methods: {
        //     },
        //     created() {
        //         console.log('Bar created');
        //     }
        // })

        function initVue() {

            const routes = [
                { path: '/', component: Main },
                // { path: '/recorder', component: Recorder },
                // { path: '/welcome', component: Welcome },
                // { path: '/home', component: Home }
            ]

            const router = new VueRouter({
                routes // short for `routes: routes`
            })

            vm = new Vue({
                el: '#app',
                router,
                vuetify: new Vuetify(),
                methods: {
                    addNewRecording() {
                        console.log('Emitting addNewRecording...');
                        this.$router.app.$emit('onAddNewRecording');
                    },
                    addNewPlayer() {
                        console.log('Emitting addNewPlayer...');
                        this.$router.app.$emit('onAddNewPlayer');
                    },
                    addNewSwarEdit() {
                        console.log('Emitting addNewSwarEdit...');
                        this.$router.app.$emit('onAddNewSwarEdit', '');
                    },
                    listFiles() {
                        console.log('Emitting listFiles...');
                        this.$router.app.$emit('onListFiles', '');
                    }
                },
                mounted() {
                    this.addNewRecording();
                    // this.addNewPlayer();
                    // this.addNewSwarEdit();
                }
            })
        }

        function loadReadmeInWelcomeTemplate() {
            // document.getElementById('welcome-template-body').innerHTML =
            //     marked.parse('# Marked in the browser\n\nRendered by **marked**.');
        }


        async function init() {
            // loadServiceWorker();
            // loadReadmeInWelcomeTemplate();
            await initDB();

            initVue();


            // createPDF();
        }



        async function initDB() {
            db = await idb.openDB(dbName, 1, {
                upgrade(db) {
                    db.createObjectStore(storeNames[0]);
                    db.createObjectStore(storeNames[1]);
                    db.createObjectStore(storeNames[2]);
                },
            });
            console.log('DB is connected.');

            dbHelper = {
                saveRecord: async (record, oldKey) => {
                    record.createdDate = new Date();
                    console.log('Saving record...', record);
                    await db.put(record.type, record, record.name);
                    if (oldKey) {
                        console.log('Deleting old key: ', oldKey);
                        await db.delete(record.type, oldKey);
                    }
                },

                getAllData: async () => {
                    let allData = [];
                    for (const storeName of storeNames) {
                        let data = await db.getAll(storeName);
                        data.forEach(d => {
                            d.type = storeName;
                        });
                        // console.log({ data });
                        allData = [...allData, ...data];
                    }
                    // console.log({ allData });
                    return allData;
                },

                deleteRecord: async (record) => {
                    await db.delete(record.type, record.name);
                },



                // addPlayerData: async (fileName, arrayBuffer) => {
                //     let name = fileName.replace(/\.[^/.]+$/, "");
                //     let record = { name, fileName, arrayBuffer, createdDate: new Date() };
                //     console.log('Saving file...', record);
                //     await db.put(stores.Players.name, record, name);
                //     // await stores.Players.store.put({fileName}, fileName);
                //     return name;
                // },

                // getAllPlayerData: async () => {
                //     // return await db.getAllKeys(stores.Players.name);
                //     let data = await db.getAll(stores.Players.name);
                //     console.log({ data });
                //     return data;
                // }

            }
            console.log('dbHelper is ready.');


            // stores.Players.store = db.transaction(stores.Players.name, 'readwrite').objectStore(stores.Players.name);
            // stores.Editors.store = db.transaction(stores.Editors.name, 'readwrite').objectStore(stores.Editors.name);
            // stores.Recordings.store = db.transaction(stores.Recordings.name, 'readwrite').objectStore(stores.Recordings.name);

            // let val = { name: 'Kaushik', id: 25 };
            // await store.put(val, "25");

            // let val = { name: 'Kaushik', id: 26 };
            // await stores.Players.store.put(val, "26");

            // const value = await store.get("25");
            // console.log({ value });

            // const tx = db.transaction(storeName, 'readwrite'); 
            // const store = tx.store;            

            // let val = {name: 'Kaushik', id: 25};
            // await store.put(storeName, val, val.id);            
            // const value = await store.get(storeName, 25);
            // console.log({value});

        }



        (async () => {
            init();
        })();




        function getFormattedDate(date) {
            var year = date.getFullYear();

            var month = (1 + date.getMonth()).toString();
            month = month.length > 1 ? month : '0' + month;

            var day = date.getDate().toString();
            day = day.length > 1 ? day : '0' + day;

            return month + '/' + day + '/' + year;
        }





        function XXcreatePDF() {

            // const doc = new jspdf.jsPDF({
            //     orientation: "landscape",
            //     unit: "in",
            //     format: [4, 2]
            // });
            // doc.text("Hello world!", 1, 1);
            // doc.save("two-by-four.pdf");


            // var doc = new jspdf.jsPDF();
            // doc.html(document.body, {
            //     callback: function (doc) {
            //         doc.save();
            //     },
            //     x: 10,
            //     y: 10
            // });

            // const myFont = ... // load the *.ttf font file as binary string
            // add the font to jsPDF
            // doc.addFileToVFS("MyFont.ttf", myFont);
            // doc.addFont("MyFont.ttf", "MyFont", "normal");
            // doc.setFont("MyFont");

        }

    </script>
    <!-- 

## localStorage
- How to read/write binary data
    const reader = new FileReader();
    reader.onload = (event) => {
        localStorage.setItem("file", event.target.result);
    }
    reader.readAsDataURL(blob);


## Use cache storage?
- Resources
    - https://web.dev/cache-api-quick-guide/
- How to detect?
    - const cacheAvailable = 'caches' in self;

-->


</body>

</html>