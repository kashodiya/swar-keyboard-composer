<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- Icon names are here: https://pictogrammers.github.io/@mdi/font/2.0.46/ -->
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@6.x/css/materialdesignicons.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vuetify/2.6.2/vuetify.css" rel="stylesheet">
    <link rel="stylesheet" href="https://webfonts.omenad.net/fonts.css">

    <script src="https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vuetify/2.6.2/vuetify.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.5.3/vue-router.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/webmidi@next/dist/iife/webmidi.iife.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/distinct-colors@3.0.0/lib/index.min.js"></script> -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/@chroma-cloud/chromajs@0.1.21/dist/chroma.umd.min.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

    <!-- For JsZip docs: https://stuk.github.io/jszip/documentation/api_zipobject/async.html -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- jsPDF docs: http://raw.githack.com/MrRio/jsPDF/master/docs/index.html     -->
    <script src="https://unpkg.com/jspdf@latest/dist/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        .cur-swar {
            color: red;
            font-size: x-large;
        }

        .viz-container {
            /* margin-top: 200px; */
            width: 100%;
            background-color: antiquewhite;
            height: 350px;
            overflow: auto;
        }


        .keyboard-swar,
        .swar-bar {
            width: 30px;
            text-align: center;
        }

        .swar-bar {
            background-color: cornsilk;
        }

        .viz-table {
            position: relative;
            margin-left: 20px;
        }

        .swar-line-table {
            /* top: 23px; */
            top: 160px;
            z-index: 100;
        }

        .keyboard-table {
            top: 150px;
        }

        .unused-swar {
            color: lightgray;
        }

        .audio-control {
            width: 400px;
        }

        .file-name-input {
            width: 400px;
        }

        ul.swar-list>li {
            display: inline-block;
            height: 52px;
        }

        ul.swar-list {
            padding-left: 0px;
        }




        .piano-keys * {
            box-sizing: border-box
        }

        .piano-keys {
            margin: 0;
        }

        .piano-keys ul {
            height: 12em;
            /* width should be dynamically calculated*/
            /* width: 34em; */
            /* margin: 5em auto; */
            /* padding: 3em 0 0 3em; */
            padding: 1em 0 0 2em;
            position: relative;
            /* border: 1px solid #160801; */
            border-radius: 1em;
            /* background: linear-gradient(to bottom right, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0)), url(https://s3-us-west-2.amazonaws.com/s.cdpn.io/187/vwood.png); */
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5) inset, 0 1px rgba(212, 152, 125, 0.2) inset, 0 5px 15px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to bottom right, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0));
        }

        .piano-keys li {
            box-sizing: border-box;
            /* margin: 0; */
            padding: 0;
            padding-left: 5px;
            list-style: none;
            position: relative;
            float: left;
        }

        code {
            background-color: transparent !important;
            font-weight: bolder !important;
        }


        .piano-keys li>code {
            position: absolute;
            bottom: 0;
            /* background-color: transparent !important; */
            font-weight: bolder;
        }

        .piano-keys li.black>code {
            color: white;
        }

        .piano-keys li>code.not-used {
            color: grey;
        }


        .piano-keys ul .white {
            height: 9em;
            /* width: 4em; */
            width: 3em;
            z-index: 1;
            border-left: 1px solid #bbb;
            border-bottom: 1px solid #bbb;
            border-radius: 0 0 5px 5px;
            box-shadow: -1px 0 0 rgba(255, 255, 255, 0.8) inset, 0 0 5px #ccc inset, 0 0 3px rgba(0, 0, 0, 0.2);
            background: linear-gradient(to bottom, #eee 0%, #fff 100%)
        }

        .piano-keys ul .white.active-key,
        .piano-keys ul .white:active {
            border-top: 1px solid #777;
            border-left: 1px solid #999;
            border-bottom: 1px solid #999;
            box-shadow: 2px 0 3px rgba(0, 0, 0, 0.1) inset, -5px 5px 20px rgba(0, 0, 0, 0.2) inset, 0 0 3px rgba(0, 0, 0, 0.2);
            background: linear-gradient(to bottom, #fff 0%, #e9e9e9 100%);
        }

        .piano-keys .black.active-key code,
        .piano-keys .black:active code,
        .piano-keys ul .white.active-key code,
        .piano-keys ul .white:active code {
            color: red;
            padding-bottom: 8px;
        }

        .piano-keys .black {
            height: 5em;
            /* width: 2em; */
            width: 2em;
            margin: 0 0 0 -1em;
            z-index: 2;
            border: 1px solid #000;
            border-radius: 0 0 3px 3px;
            box-shadow: -1px -1px 2px rgba(255, 255, 255, 0.2) inset, 0 -5px 2px 3px rgba(0, 0, 0, 0.6) inset, 0 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(45deg, #222 0%, #555 100%)
        }

        .piano-keys .black.active-key,
        .piano-keys .black:active {
            box-shadow: -1px -1px 2px rgba(255, 255, 255, 0.2) inset, 0 -2px 2px 3px rgba(0, 0, 0, 0.6) inset, 0 1px 2px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to right, #444 0%, #222 100%);
        }

        .g,
        .a,
        .b,
        .d,
        .e {
            margin: 0 0 0 -1em;
        }

        .piano-keys ul li:first-child {
            border-radius: 5px 0 5px 5px
        }

        .piano-keys ul li:last-child {
            border-radius: 0 5px 5px 5px
        }

        .current-swar {
            color: red !important;
            font-weight: bolder !important;
        }

        .ome-class-name-radio {
            font-size: x-small !important;
        }






        ul.swar-line-vibhag {
            text-align: justify;
            padding-left: 0px;
            padding-right: 4px;
            padding-top: 5px;
            white-space: nowrap;
        }

        ul.swar-line-vibhag:after {
            content: '';
            display: inline-block;
            width: 100%;
        }

        ul.swar-line-vibhag:before {
            content: '';
            display: block;
            margin-top: -1.25em;
        }

        .swar-line-vibhag li {
            display: inline-block;
            margin-right: -.25em;
            position: relative;
            top: 1.25em;
            height: 50px;
            /* text-align: center; */
        }

        .swar-line-preview {
            border-collapse: collapse;
        }

        .swar-line-preview td {
            border: 2px solid Gray;
        }

        .swar-line-bit-symbol {
            /* font-size: larger !important; */
        }

        .swar-text-area {
            font-family: monospace, Courier, 'Courier New';
        }
    </style>
</head>

<body>

    <template id="home-template">
        <div>
            <audio id="mainAudio" ref="mainAudio" src="audio1.ogg" controls preload></audio>
            <!-- <ul>
                <li v-for="(d, i) in swarTimeData" :class="i == prevSwarIndex ? 'cur-swar' : ''">
                    {{d.swar}} - {{d.time}}
                </li>
            </ul>
            {{minSwarIndex}},
            {{maxSwarIndex}} -->
            <!-- <v-btn @click="test">Test</v-btn> -->
            <div class="viz-container">
                <table class="viz-table keyboard-table">
                    <tr>
                        <td v-for="kbSwar in keyboardLine">
                            <div :class="getClassForKeyboardSwar(kbSwar)">
                                {{kbSwar.swar}}
                            </div>
                        </td>
                    </tr>
                    <!-- <tr>
                        <td v-for="i in (maxSwarIndex - minSwarIndex) + 1">
                            <div class="swar-bar ome-bhatkhande-english">
                                {{swars[i + minSwarIndex - 1]}}
                            </div>
                        </td>
                    </tr> -->
                </table>
                <table class="viz-table swar-line-table" ref="swarLineTable">
                    <tr v-for="line in swarLines">
                        <td v-for="lineData in line">
                            <div :data-bg-color="lineData.color" :ref="'swar-bar-' + lineData.swarTimeIndex"
                                class="swar-bar ome-bhatkhande-english" :style="getSwarbarStyle(lineData)">
                                {{lineData.swar}}
                            </div>
                        </td>
                    </tr>
                </table>

                <!-- <ul> 
                    <li v-for="i in (maxSwarIndex - minSwarIndex) + 1">
                        {{swars[i + minSwarIndex - 1]}}
                    </li>
                </ul> -->

            </div>
    </template>

    <div id="app">

        <v-app>
            <v-app-bar app color="deep-purple accent-4" dark>
                <v-toolbar-title style="cursor: pointer" @click="$router.push('/')">
                    Swar Keyboard Composer
                </v-toolbar-title>
                <v-spacer></v-spacer>

                <v-btn small @click="addNewSwarEdit" class="mr-3">
                    New Swar Editor
                    <v-icon right>mdi-lead-pencil</v-icon>
                </v-btn>


                <v-btn small @click="addNewPlayer" class="mr-3">
                    New Player
                    <v-icon right>mdi-play-circle-outline</v-icon>
                </v-btn>

                <v-btn small @click="addNewRecording">
                    New Recording
                    <v-icon right>mdi-record-rec</v-icon>
                </v-btn>
            </v-app-bar>

            <v-main>
                <v-container fluid>
                    <!-- <Main></Main> -->

                    <router-view></router-view>
                </v-container>
            </v-main>

            <v-footer app>
                Kaushik Ashodiya
            </v-footer>
        </v-app>
    </div>

    <!-- </div> -->

    <template id="main-template">
        <div>
            <v-tabs show-arrows background-color="deep-purple accent-4" dark v-model="curTab" height="40">
                <v-tab v-for="(tab, tabIndex) in tabs" :key="'tab-' + tabIndex">
                    <h5>
                        {{tab.title}}
                    </h5>
                    <template v-if="tabIndex > 0">
                        <v-spacer class="ml-5"></v-spacer>
                        <v-btn x-small icon @click="closeTab(tabIndex)">
                            <v-icon>mdi-close-circle</v-icon>
                        </v-btn>
                    </template>
                </v-tab>
            </v-tabs>
            <!-- <router-view></router-view> -->

            <!-- <Main></Main> -->

            <!-- <v-tab-item v-for="tab of tabs" :key="tab.id" :value="tab.route">
                <router-view></router-view>
              </v-tab-item> -->

            <v-tabs-items v-model="curTab">
                <v-tab-item v-for="(tab, tabIndex) in tabs" :key="'tab-body-' + tabIndex">
                    <v-card class="pa-5" outlined>
                        <template v-if="tabIndex == 0">
                            <div>
                                <Welcome></Welcome>
                            </div>
                        </template>
                        <template v-else>
                            <div v-if="tab.type == 'rec'">
                                <Recorder :ref="tab.type + '-' + tabIndex"></Recorder>
                            </div>
                            <div v-if="tab.type == 'play'">
                                <Player :ref="tab.type + '-' + tabIndex"></Player>
                            </div>
                            <div v-if="tab.type == 'swarEdit'">
                                <Swaredit :ref="tab.type + '-' + tabIndex" :swar-txt="tab.swarTxt"></Swaredit>
                            </div>
                        </template>
                    </v-card>
                </v-tab-item>
            </v-tabs-items>
        </div>
    </template>

    <template id="welcome-template">
        <div ref="welcome-template-body" v-html="bodyHTML">
        </div>
    </template>



    <template id="recorder-template">
        <div>
            <p>
                <v-btn :disabled="!mediaRecorderCreated && recState != 'NOT-RECORDING'" @click="startRecording">Start
                    Recording</v-btn>
                <v-btn :disabled="recState != 'RECORDING'" @click="stopRecording">Stop Recording</v-btn>
                <v-btn :disabled="recState != 'STOPPED'" @click="clearAll">Clear all</v-btn>
            </p>
            <p XXv-show="audioDataReady">
                <audio id="recordingAudio" ref="recordingAudio" controls class="audio-control"></audio>
            </p>

            <!-- {{recState}},
            deviceId = {{deviceId}},
            deviceName = {{deviceName}},
            recStartDateTime = {{recStartDateTime}} -->

            <p>
                <v-btn :disabled="!audioDataReady" @click="download">Download</v-btn>
            </p>

            <p>
                <v-form ref="form" @submit.prevent="download">
                    <v-text-field class="file-name-input" :rules="[rules.required]" v-model="projectFileName"
                        label="File name"></v-text-field>
                </v-form>
            </p>

            <ul class="swar-list">
                <li @click="swarTimeDataItemClicked(d)" v-for="d in swarTimeData">
                    <code class="ome-bhatkhande-english">{{d.swar}}</code>
                    <!-- , {{d.startTime}}, {{d.endTime}}, {{d.duration}} -->
                </li>
            </ul>


            <v-snackbar v-model="showMesssage">
                {{message}}
            </v-snackbar>

        </div>
    </template>


    <!-- <br>
    <ul id="keyboard">
        <li note="C" class="white">A</li>
        <li note="C#" class="black">W</li>
        <li note="D" class="white offset">S</li>
        <li note="D#" class="black">E</li>
        <li note="E" class="white offset">D</li>
        <li note="F" class="white">F</li>
        <li note="F#" class="black">T</li>
        <li note="G" class="white offset">G</li>
        <li note="G#" class="black">Y</li>
        <li note="A" class="white offset">H</li>
        <li note="A#" class="black">U</li>
        <li note="B" class="white offset">J</li>
        <li note="C2" class="white">K</li>
        <li note="C#2" class="black">O</li>
        <li note="D2" class="white offset">L</li>
        <li note="D#2" class="black">P</li>
        <li note="E2" class="white offset">;</li>
      </ul> -->

    <template id="player-template">
        <div>
            <v-file-input v-model="chosenFile" label="Upload zip file"></v-file-input>
            <audio ref="playerAudio" controls></audio>

            <p v-if="swarTimeData != null">
            <ul class="swar-list">
                <li @click="swarTimeDataItemClicked(d)" v-for="d in swarTimeData">
                    <code class="ome-bhatkhande-english" :ref="'player-swar-' + d.keyIndex">{{d.swar}}</code>

                </li>
            </ul>
            <v-btn @click="openFormatSwars" x-small v-if="swarTimeData != null">Format swars</v-btn>

            </p>

            <!-- Credits to piano css: https://codepen.io/zastrow/pen/kxdYdk -->
            <!-- <div class="piano-keys">
                <ul class="set">


                    <li class="white f xb"></li>
                    <li class="black fs xas"></li>
                    <li class="white g xa"></li>
                    <li class="black gs xgs"></li>
                    <li class="white a xg"></li>
                    <li class="black as xfs"></li>
                    <li class="white b xf"></li>
                    <li class="white c xe"></li>
                    <li class="black cs xds"></li>
                    <li class="white d xd"></li>
                    <li class="black ds xcs"></li>
                    <li class="white e xc"></li>

                    <li class="white f xb">
                        <code class="ome-bhatkhande-english">s</code>
                    </li>
                    <li class="black fs xas">
                        <code class="ome-bhatkhande-english">R</code>
                    </li>
                    <li class="white g xa">
                        <code class="ome-bhatkhande-english">r</code>
                    </li>
                    <li class="black gs xgs">
                        <code class="ome-bhatkhande-english">G</code>
                    </li>

                </ul>
            </div> -->

            <div class="piano-keys" v-show="pianoKeysInUse.length > 0" ref="pianoKeys">
                <ul class="set">
                    <li :class="k.liClass" :data-key-index="k.keyIndex" v-for="k in pianoKeysInUse"
                        :ref="'piano-key-' + k.keyIndex">
                        <code :class="'ome-bhatkhande-english ' + (k.notUsed ? 'not-used' : '')">{{k.swar}}</code>
                    </li>
                </ul>
            </div>

            <!-- <div v-if="minSwarIndex != -1">
                minSwarIndex = {{minSwarIndex}} {{pianoKeys[minSwarIndex]}},
                maxSwarIndex = {{maxSwarIndex}} {{pianoKeys[maxSwarIndex]}}
            </div> -->


        </div>
    </template>


    <template id="swaredit-template">
        <div>
            <v-switch v-model="showGuide" label="Show guide"></v-switch>

            <div v-show="showGuide">
                <h3>Swar formatting</h3>
                <p>
                <ul>
                    <li>
                        Each aavertan on new line
                    </li>
                    <li>
                        Each vibhag seperated by a '|'' (pipe)
                    </li>
                    <li>
                        Each bit seperated by a space
                    </li>
                    <li>
                        Read guide for swar keys and other symbols <a href="https://omenad.github.io/fonts/"
                            target="_blank">here</a>
                    </li>
                </ul>
                </p>
                <p>
                <h4>Tips:</h4>
                <ul>
                    <li>
                        Use '=' (3 dots) to indicate continuation of previous bit/swar.
                    </li>
                    <li>
                        Use '-' (underscore) for empty bit/swar.
                    </li>
                </ul>
                </p>

            </div>

            <v-textarea class="mb-3 swar-text-area" hide-details outlined label="Swar lines" v-model="formattedSwars">
            </v-textarea>

            <p>
            <table class="swar-line-preview mb-3" ref="swar-line-preview-table">
                <tr v-for="(line, lineIndex) in swarLines">
                    <td v-for="(vibhag, vibhagIndex) in line">
                        <ul class="swar-line-vibhag">
                            <li v-for="(bitInfo, bitIndex) in vibhag"
                                :ref="'bit-' + lineIndex + '-' + vibhagIndex + '-' + bitIndex">
                                <code :class="bitInfo.isOmenad ? omeClassName : 'swar-line-bit-symbol'"
                                    v-html="bitInfo.symbol">
                                </code>
                            </li>
                        </ul>
                    </td>
                </tr>
            </table>
            <v-btn x-small @click="adjustBitGap(swarLineBitsGapIncrement)">Increase Gap</v-btn>
            <v-btn x-small @click="adjustBitGap(swarLineBitsGapIncrement * -1)">Decrease Gap</v-btn>

            <v-btn x-small @click="createPDF">Download PDF</v-btn>

            <!-- <v-btn x-small @click="fixSwarLineBitsWidth">Aligh bits vertically</v-btn> -->


            <!-- <v-slider class="mt-5" min="0" max="200" label="Adjust gap between bits:" v-model="swarLineBitsGap"></v-slider> -->

            </p>


            <v-btn XXclick="openFormatSwars" x-small>Download swars</v-btn>
            <v-btn XXclick="openFormatSwars" x-small>Download zip</v-btn>
            <v-switch v-model="allowLyricsLines" label="Allow lyrics lines before swar lines"></v-switch>

            <v-divider class="mt-5 mb-5"></v-divider>

            <h4>Preview</h4>

            Use fonts/language:
            <v-radio-group row v-model="omeClassName">
                <v-radio class="ome-class-name-radio" v-for="oc in omeClassNames" :key="oc.className" :label="oc.title"
                    :value="oc.className"></v-radio>
            </v-radio-group>



            <v-divider class="mt-5 mb-5"></v-divider>



        </div>
    </template>


    <script>

        var keys = "C#3 D3 D#3 E3 F3 F#3 G3 G#3 A3 A#3 B3 C4 C#4 D4 D#4 E4 F4 F#4 G4 G#4 A4 A#4 B4 C5 C#5 D5 D#5 E5 F5 F#5 G5 G#5 A5 A#5 B5 C6".split(" ");
        var swars = "sl Rl rl Gl gl ml Ml pl Dl dl Nl nl s R r G g m M p D d N n su Ru ru Gu gu mu Mu pu Du du Nu nu".split(" ");
        var swarsEng = ".S .r .R .g .G .M .m .P .d .D .n .N S r R g G M m P d D n N S. r. R. g. G. M. m. P. d. D. n. N.".split(" ");
        let colors = ['#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#42d4f4', '#f032e6', '#bfef45', '#fabed4', '#469990', '#dcbeff', '#9A6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#a9a9a9', '#ffffff', '#000000'];
        let oneOctive = ['black cs', 'white d', 'black ds', 'white e', 'white f', 'black fs', 'white g', 'black gs', 'white a', 'black as', 'white b', 'white c'];

        // let pianoOctiveColorPattern = "W B W B W W B W B W B W".split();

        let pianoKeys = [...oneOctive, ...oneOctive, ...oneOctive];
        let tickInterval = 50;
        let tickIntervalMs = (tickInterval / 1000);
        let audioDuration = 0;
        let swarBarBgOpacify = '10';
        let prevSwarIndex = -1;
        // let swarLineTableOffsetTop = 0;         //See mounted method
        let swarTimeData = [
            { swar: 'd', timeS: 0.2, timeE: 1.2 },
            { swar: 'm', timeS: 1.2, timeE: 1.5 },
            { swar: 'g', timeS: 1.5, timeE: 2.1 },
            { swar: 'M', timeS: 2.1, timeE: 4.1 },
            { swar: 'p', timeS: 4.1, timeE: 5.5 },
            { swar: 'D', timeS: 5.5, timeE: 6.1 },
            { swar: 'n', timeS: 6.1, timeE: 6.7 },
        ];
        let swarBarHeightMultiplier = 80;
        let { minSwarIndex, maxSwarIndex } = getMinMaxSwar(swarTimeData);
        let { keyboardLine, swarLines, totalHeight } = getVizLines(swarTimeData);
        let timer = null;
        let audio = null;
        let vm = null;

        // let swarTxt = 'Used to pass text like a prop';



        const SwarEdit = Vue.component('Swaredit', {
            template: '#swaredit-template',
            props: ['swarTxt'],
            data() {
                return {
                    showGuide: false,
                    showFormatSwars: false,
                    allowLyricsLines: true,
                    formattedSwars: '',
                    omeClassName: 'ome-bhatkhande-english',
                    swarLineBitsGapIncrement: 2,
                    swarLines: [],
                    omeClassNames: [
                        { className: 'ome-bhatkhande-english', title: 'English' },
                        { className: 'ome-bhatkhande-hindi', title: 'Hindi' },
                        { className: 'ome-bhatkhande-punjabi', title: 'Punjabi' },
                        { className: 'ome-swarlipi', title: 'Swarlipi' }
                    ],

                }
            },
            watch: {
                allowLyricsLines() {
                    this.transformFromattedSwars();
                    // formattedSwars(this.formattedSwars);
                },
                formattedSwars(newTxt) {
                    this.transformFromattedSwars();
                }
            },
            methods: {
                transformFromattedSwars() {
                    let lines = this.formattedSwars.split('\n');
                    console.log({ lines });
                    // this.lines = [];
                    // lines.forEach(line => {
                    //     let vibhags = line.split('|');

                    // });

                    lines = lines.filter(l => l.trim().length != '')

                    this.swarLines = [];
                    lines.forEach((line, lineIndex) => {
                        let vibhagList = [];
                        let vibhags = line.split('|');
                        vibhags.forEach(vibhag => {
                            let bits = vibhag.trim().split(' ').map(b => {
                                let isOmenad = true;
                                let symbol = b;
                                if (b == '=') {
                                    symbol = '~';
                                    // symbol = '&#864;';
                                    isOmenad = false;
                                } else if (b == '-') {
                                    symbol = '';
                                    isOmenad = false;
                                } else if (this.allowLyricsLines && lineIndex % 2 == 0) {
                                    isOmenad = false;
                                }
                                return { symbol, isOmenad };
                            });
                            vibhagList.push(bits);
                        });
                        this.swarLines.push(vibhagList);
                    });
                    console.log({ swarLines: this.swarLines });
                },
                // fixSwarLineBitsWidth(){
                //     this.adjustBitGap(0);                    
                // },
                adjustBitGap(amount) {
                    let maxWidth = 0;
                    this.swarLines.forEach((line, lineIndex) => {
                        line.forEach((vibhag, vibhagIndex) => {
                            vibhag.forEach((bit, bitIndex) => {
                                let refId = 'bit-' + lineIndex + '-' + vibhagIndex + '-' + bitIndex;
                                let width = this.$refs[refId][0].offsetWidth;
                                // console.log({refId, width});
                                if (width > maxWidth) maxWidth = width;
                            });
                        });
                    });

                    this.swarLines.forEach((line, lineIndex) => {
                        line.forEach((vibhag, vibhagIndex) => {
                            vibhag.forEach((bit, bitIndex) => {
                                let refId = 'bit-' + lineIndex + '-' + vibhagIndex + '-' + bitIndex;
                                this.$refs[refId][0].style.width = maxWidth + amount + 'px';
                            });
                        });
                    });

                },
                openFormatSwars() {
                    // this.formattedSwars = this.swarTimeData.map(d => d.swar).join(' ');
                    // this.showFormatSwars = true;

                    let swarTxt = this.swarTimeData.map(d => d.swar).join(' ');
                    this.$router.app.$emit('onAddNewSwarEdit', swarTxt);

                    // console.log({ show });
                },
                async createPDF() {
                    let table = this.$refs['swar-line-preview-table'];
                    var doc = new jspdf.jsPDF();

                    //URLs of TTF file are in: https://webfonts.omenad.net/fonts.css


                    let fontBlob = await fetch('https://webfonts.omenad.net/webfontkit/omebhatkhandeenglish-webfont.ttf').then(r => r.blob());


                    var binaryStringToUint8Array = function (binary_string) {
                        var len = binary_string.length;
                        var bytes = new Uint8Array(len);
                        for (var i = 0; i < len; i++) {
                            bytes[i] = binary_string.charCodeAt(i);
                        }
                        return bytes;
                    };

                    const reader = new FileReader();
                    let fontBin = reader.readAsDataURL(fontBlob);
                    doc.addFileToVFS("ome_bhatkhande_english", binaryStringToUint8Array(fontBlob));
                    doc.addFont("omebhatkhandeenglish-webfont.ttf", "ome_bhatkhande_english", "normal");
                    doc.setFont("ome_bhatkhande_english");


                    // const myFont = ... // load the *.ttf font file as binary string
                    // add the font to jsPDF
                    // doc.addFileToVFS("MyFont.ttf", myFont);
                    // doc.addFont("MyFont.ttf", "MyFont", "normal");
                    // doc.setFont("MyFont");

                    doc.html(table, {
                        callback: function (doc) {
                            doc.save();
                        },
                        x: 10,
                        y: 10
                    });
                }
            },
            mounted() {
            },
            created() {
                console.log('SwarEdit created');
                this.formattedSwars = this.swarTxt;
                console.log({ swarTxt: this.swarTxt });

                //TODO: Remove following
                if (this.formattedSwars == '') {
                    this.formattedSwars =
                        ["- - - - | - - - - | sa da gu ru",
                            "s r g m | r g m p | g m p d",
                            "se = = = | kya = maan gu | ji na ke =",
                            "r g m p | s r g m | g m p d"].join('\n');
                }

            }
        })

        const Player = Vue.component('Player', {
            template: '#player-template',
            data() {
                return {
                    tickInterval: 10,
                    // showFormatSwars: false,
                    // allowLyricsLines: false,
                    // formattedSwars: '',
                    // omeClassName: 'ome-bhatkhande-english',
                    // swarLineBitsGapIncrement: 2,
                    // swarLines: [],
                    // omeClassNames: [
                    //     { className: 'ome-bhatkhande-english', title: 'English' },
                    //     { className: 'ome-bhatkhande-hindi', title: 'Hindi' },
                    //     { className: 'ome-bhatkhande-punjabi', title: 'Punjabi' },
                    //     { className: 'ome-swarlipi', title: 'Swarlipi' }
                    // ],
                    timer: null,
                    audioDuration: 0,
                    chosenFile: null,
                    swarTimeData: null,
                    pianoKeysInUse: [],
                    minSwarIndex: -1,
                    maxSwarIndex: -1,
                    pianoKeys, swars, keys       //These come from global vars
                }
            },
            watch: {
                // swarLineBitsGap(gap){
                //     //=
                //     // console.log(gap);
                //     //Find max width
                //     let maxWidth = 0;
                //     this.swarLines.forEach((line, lineIndex) => {
                //         line.forEach((vibhag, vibhagIndex) => {
                //             vibhag.forEach((bit, bitIndex) => {
                //                 let refId = 'bit-' + lineIndex + '-' + vibhagIndex + '-' + bitIndex;
                //                 let width = this.$refs[refId][0].offsetWidth;
                //                 // console.log({refId, width});
                //                 if(width > maxWidth) maxWidth = width;
                //             });
                //         });
                //     });

                //     this.swarLines.forEach((line, lineIndex) => {
                //         line.forEach((vibhag, vibhagIndex) => {
                //             vibhag.forEach((bit, bitIndex) => {
                //                 let refId = 'bit-' + lineIndex + '-' + vibhagIndex + '-' + bitIndex;
                //                 this.$refs[refId][0].style.width = gap + 'px';
                //             });
                //         });
                //     });


                // },

                chosenFile() {
                    console.log('File loaded');
                    this.readZipFile();
                },
                // allowLyricsLines() {
                //     this.transformFromattedSwars();
                //     // formattedSwars(this.formattedSwars);
                // },
                // formattedSwars(newTxt) {
                //     this.transformFromattedSwars();
                // }
            },
            methods: {
                // transformFromattedSwars() {
                //     let lines = this.formattedSwars.split('\n');
                //     console.log({ lines });
                //     // this.lines = [];
                //     // lines.forEach(line => {
                //     //     let vibhags = line.split('|');

                //     // });

                //     this.swarLines = [];
                //     lines.forEach((line, lineIndex) => {
                //         let vibhagList = [];
                //         let vibhags = line.split('|');
                //         vibhags.forEach(vibhag => {
                //             let bits = vibhag.trim().split(' ').map(b => {
                //                 let isOmenad = true;
                //                 let symbol = b;
                //                 if (b == '...') {
                //                     symbol = '~';
                //                     isOmenad = false;
                //                 } else if (b == '-') {
                //                     symbol = '';
                //                     isOmenad = false;
                //                 } else if (this.allowLyricsLines && lineIndex % 2 == 0) {
                //                     isOmenad = false;
                //                 }
                //                 return { symbol, isOmenad };
                //             });
                //             vibhagList.push(bits);
                //         });
                //         this.swarLines.push(vibhagList);
                //     });
                //     console.log({ swarLines: this.swarLines });
                // },
                // // fixSwarLineBitsWidth(){
                // //     this.adjustBitGap(0);                    
                // // },
                // adjustBitGap(amount) {
                //     let maxWidth = 0;
                //     this.swarLines.forEach((line, lineIndex) => {
                //         line.forEach((vibhag, vibhagIndex) => {
                //             vibhag.forEach((bit, bitIndex) => {
                //                 let refId = 'bit-' + lineIndex + '-' + vibhagIndex + '-' + bitIndex;
                //                 let width = this.$refs[refId][0].offsetWidth;
                //                 // console.log({refId, width});
                //                 if (width > maxWidth) maxWidth = width;
                //             });
                //         });
                //     });

                //     this.swarLines.forEach((line, lineIndex) => {
                //         line.forEach((vibhag, vibhagIndex) => {
                //             vibhag.forEach((bit, bitIndex) => {
                //                 let refId = 'bit-' + lineIndex + '-' + vibhagIndex + '-' + bitIndex;
                //                 this.$refs[refId][0].style.width = maxWidth + amount + 'px';
                //             });
                //         });
                //     });

                // },
                openFormatSwars() {
                    // this.formattedSwars = this.swarTimeData.map(d => d.swar).join(' ');
                    // this.showFormatSwars = true;

                    let swarTxt = this.swarTimeData.map(d => d.swar).join(' ');
                    this.$router.app.$emit('onAddNewSwarEdit', swarTxt);

                    // console.log({ show });
                },
                swarTimeDataItemClicked(d) {
                    // console.log({ swarData: d });
                    this.$refs['piano-key-' + d.keyIndex][0].classList.add('active-key');
                    setTimeout(() => {
                        this.$refs['piano-key-' + d.keyIndex][0].classList.remove('active-key');
                    }, 2000);
                },
                preparePiano() {
                    //pianoKeys

                    let indexes = this.swarTimeData.map(d => {
                        d.swarIndex = this.swars.indexOf(d.swar);
                        return d.swarIndex;
                    });
                    this.minSwarIndex = Math.min.apply(Math, indexes);
                    this.maxSwarIndex = Math.max.apply(Math, indexes);

                    if (this.pianoKeys[this.minSwarIndex].indexOf('black') > -1) {
                        console.log('Showing one white key to the left of the piano');
                        this.minSwarIndex--;
                    }
                    if (this.pianoKeys[this.maxSwarIndex].indexOf('black') > -1) {
                        console.log('Showing one white key to the right of the piano');
                        this.maxSwarIndex++;
                    }

                    let wKeyCount = 0;
                    let bKeyCount = 0;
                    for (let i = this.minSwarIndex; i <= this.maxSwarIndex; i++) {
                        let notUsed = this.swarTimeData.findIndex(d => d.keyIndex == i) == -1;
                        this.pianoKeysInUse.push({
                            keyIndex: i,
                            swar: this.swars[i],
                            liClass: this.pianoKeys[i],
                            notUsed
                        })
                        if (this.pianoKeys[i].indexOf('white') > -1) wKeyCount++;
                        if (this.pianoKeys[i].indexOf('black') > -1) bKeyCount++;
                    }
                    //TODO: Following 2.4 is a by trial and error, find out better way
                    let pianoWidth = (wKeyCount * 2.8) + (bKeyCount * 2);
                    console.log({ wKeyCount, bKeyCount, pianoWidth });
                    this.$refs.pianoKeys.style.width = pianoWidth + 'em';
                },
                readZipFile() {
                    if (!this.chosenFile) { this.data = "No File Chosen" };
                    var reader = new FileReader();
                    reader.onload = (ev) => {
                        JSZip.loadAsync(ev.target.result).then((zip) => {
                            console.log({ zip });
                            for (var fileName of Object.keys(zip.files)) {
                                console.log(fileName);
                                if (fileName.indexOf('-audio.ogg') != -1) {
                                    zip.file(fileName).async("ArrayBuffer").then((audioData) => {
                                        // console.log({ audioData });
                                        const blob = new Blob([audioData], { type: "audio/wav" });
                                        this.$refs.playerAudio.src = window.URL.createObjectURL(blob);
                                        console.log('Successfully got audio from zip file.')
                                    })
                                } else if (fileName.indexOf('-swarTimeData.json') != -1) {
                                    zip.file(fileName).async("text").then((jsonTxt) => {
                                        // console.log({ jsonTxt });
                                        this.swarTimeData = JSON.parse(jsonTxt);
                                        // console.log(this.swarTimeData);
                                        this.preparePiano();
                                        console.log('Successfully got swarTimeData from zip file.')
                                    })
                                }
                            }
                        }).catch(function (err) {
                            console.error("Failed to open ZIP file:", err);
                        })
                    };
                    reader.onerror = function (err) {
                        console.error("Failed to read file", err);
                    }

                    const arrayBuffer = reader.readAsArrayBuffer(this.chosenFile);
                },
                audioPlaying() {
                    console.log('onPlaying...');
                    //TODO: Make all swrs color black, because user may be playing it again
                    this.timer = setInterval(this.onTick, this.tickInterval);
                    // this.startAnim();
                },
                audioPaused() {
                    console.log('audioPaused...');
                    clearInterval(this.timer);
                    // this.stopAnim();
                },
                audioEnded() {
                    console.log('audioEnded...');
                    clearInterval(this.timer);
                    // this.stopAnim();
                    this.prevSwarIndex = -1;
                },
                audioSeeking(e) {
                    // console.log('audioSeeking...', this.$refs.playerAudio.currentTime);
                    this.onTick();
                },
                onTick() {
                    let curTime = this.$refs.playerAudio.currentTime * 1000;
                    let index = this.swarTimeData.findIndex(d => curTime >= d.startTime && curTime <= d.endTime);
                    if (index != -1) {
                        // console.log(curTime, index);

                        let keyIndex = this.swarTimeData[index].keyIndex;
                        let duration = this.swarTimeData[index].duration;
                        this.$refs['piano-key-' + keyIndex][0].classList.add('active-key');
                        setTimeout(() => {
                            this.$refs['piano-key-' + keyIndex][0].classList.remove('active-key');
                        }, duration);

                        this.$refs['player-swar-' + keyIndex][0].classList.add('current-swar');
                        // setTimeout(() => {
                        //     this.$refs['player-swar-' + keyIndex][0].classList.remove('current-swar');
                        // }, duration);

                        // // console.log(this.swarTimeData[index], curTime, this.swarTimeData[index].time - curTime);
                        // this.prevSwarIndex = index;
                        // this.highlightSwarBar(index);
                        // let curSwarBar = this.$refs['swar-bar-' + index][0];
                        // // console.log({curSwarBar}, curSwarBar.dataset['bgColor']);
                        // curSwarBar.style.backgroundColor = curSwarBar.dataset['bgColor'] + 'F5';
                    }
                },
                // async createPDF() {
                //     let table = this.$refs['swar-line-preview-table'];
                //     var doc = new jspdf.jsPDF();

                //     //URLs of TTF file are in: https://webfonts.omenad.net/fonts.css


                //     let fontBlob = await fetch('https://webfonts.omenad.net/webfontkit/omebhatkhandeenglish-webfont.ttf').then(r => r.blob());


                //     var binaryStringToUint8Array = function (binary_string) {
                //         var len = binary_string.length;
                //         var bytes = new Uint8Array(len);
                //         for (var i = 0; i < len; i++) {
                //             bytes[i] = binary_string.charCodeAt(i);
                //         }
                //         return bytes;
                //     };

                //     const reader = new FileReader();
                //     let fontBin = reader.readAsDataURL(fontBlob);
                //     doc.addFileToVFS("ome_bhatkhande_english", binaryStringToUint8Array(fontBlob));
                //     doc.addFont("omebhatkhandeenglish-webfont.ttf", "ome_bhatkhande_english", "normal");
                //     doc.setFont("ome_bhatkhande_english");


                //     // const myFont = ... // load the *.ttf font file as binary string
                //     // add the font to jsPDF
                //     // doc.addFileToVFS("MyFont.ttf", myFont);
                //     // doc.addFont("MyFont.ttf", "MyFont", "normal");
                //     // doc.setFont("MyFont");

                //     doc.html(table, {
                //         callback: function (doc) {
                //             doc.save();
                //         },
                //         x: 10,
                //         y: 10
                //     });
                // }
            },
            mounted() {
                let audio = this.$refs.playerAudio;
                // audio.currentTime = 24 * 60 * 60;
                // audio.addEventListener('timeupdate', setDuration = () => {
                //     this.audioDuration = this.audio.duration;
                //     console.log('duration=', this.audio.duration);
                //     this.audio.currentTime = 0;
                //     this.audio.removeEventListener('timeupdate', setDuration)
                // })
                audio.addEventListener('playing', this.audioPlaying);
                audio.addEventListener('pause', this.audioPaused);
                audio.addEventListener('ended', this.audioEnded);
                audio.addEventListener('seeking', this.audioSeeking);

                //TODO: Remove following
                // this.showFormatSwars = true;
                // this.formattedSwars =
                //     ["- - - - | - - - - | sa da gu ru",
                //         "s r g m | r g m p | g m p d",
                //         "se ... ... ... | kya ... maan gu | ji na ke ...",
                //         "r g m p | s r g m | g m p d"].join('\n');
            },
            created() {
                console.log('Player created');
            }
        })



        const Recorder = Vue.component('Recorder', {
            template: '#recorder-template',
            data() {
                return {
                    audioDataReady: false,
                    rules: {
                        required: value => !!value || 'Please enter download file name.'
                    },
                    recState: 'NOT-RECORDING',
                    showMesssage: false,
                    message: '',
                    deviceId: '',
                    deviceName: '',
                    mediaRecorderCreated: false,
                    recStartDateTime: null,
                    swarTimeData: [],
                    projectFileName: '',
                    pianoKeyDownInfo: null,
                    keys, swars, swarsEng            //These come from global vars
                }
            },
            methods: {
                generateProjectFileName() {
                    const date = new Date();
                    var fileName = date.getFullYear() + '-'
                        + ('0' + (date.getMonth() + 1)).slice(-2) + '-'
                        + ('0' + date.getDate()).slice(-2) + '-'
                        + ('0' + date.getHours()).slice(-2) + '-'
                        + ('0' + date.getMinutes()).slice(-2) + '-'
                        + ('0' + date.getSeconds()).slice(-2);
                    return fileName;
                },
                download() {
                    this.$refs.form.validate();
                    if (this.projectFileName == '') {
                        this.message = "Please enter file name";
                        this.showMesssage = true;
                        return;
                    }


                    let swarList = this.swarTimeData.map(d => d.swar);
                    let swarEngList = this.swarTimeData.map(d => this.swarsEng[d.keyIndex]);
                    let plainSwarTimeData = this.swarTimeData.map(d => {
                        let { duration, startTime, endTime, keyIndex, swar } = d;
                        return { duration, startTime, endTime, keyIndex, swar };
                    });


                    let zip = this.$options.zip;
                    zip.file(this.projectFileName + '-swarTimeData.json', JSON.stringify(plainSwarTimeData));
                    zip.file(this.projectFileName + '-omenad-swars.txt', swarList.join(' '));
                    zip.file(this.projectFileName + '-eng-swars.txt', swarEngList.join(' '));
                    zip.file(this.projectFileName + '-audio.ogg', this.$options.audioBlob, { base64: true });

                    zip.generateAsync({ type: "blob" }).then((content) => {
                        saveAs(content, this.projectFileName + '.zip');
                    });
                },
                clearAll() {
                    this.$options.zip = new JSZip();
                    this.$options.chunks = [];
                    this.$refs.recordingAudio.src = '';
                    this.swarTimeData = [];
                    this.audioDataReady = false;
                    this.recState = 'NOT-RECORDING';
                    this.recStartDateTime = null;
                    this.projectFileName = this.generateProjectFileName();
                },
                swarTimeDataItemClicked(d) {
                    console.log({ swarTimeDataItem: d });
                    // console.table(this.swarTimeData);
                },
                stopRecording() {
                    let mediaRecorder = this.$options.mediaRecorder;
                    mediaRecorder.stop();
                    this.recState = 'STOPPED';
                    this.calculateSwarTimes();
                },
                startRecording() {
                    let chunks = this.$options.chunks;
                    let mediaRecorder = this.$options.mediaRecorder;
                    console.log('Using Media Recorder: ', mediaRecorder);
                    // let recordingAudio = document.getElementById('recordingAudio');
                    let recordingAudio = this.$refs.recordingAudio;
                    console.log('Starting recording...for 4 sec...');
                    mediaRecorder.start();
                    this.recState = 'RECORDING';
                    this.recStartDateTime = new Date();

                    // setTimeout(() => {
                    //     console.log('Stopping recording...');
                    //     mediaRecorder.stop();
                    // }, 4000);

                    mediaRecorder.onstop = async (e) => {
                        let chunks = this.$options.chunks;
                        const blob = new Blob(chunks, { 'type': 'audio/ogg; codecs=opus' });
                        this.$options.audioBlob = blob;
                        chunks = [];
                        const audioURL = window.URL.createObjectURL(blob);
                        recordingAudio.src = audioURL;
                        this.audioDataReady = true;
                    }
                    mediaRecorder.ondataavailable = function (e) {
                        console.log('Getting chunks...')
                        chunks.push(e.data);
                    }
                },
                calculateSwarTimes() {
                    //Take recStartDateTime and iterate swarTimeData to set time and duration
                    this.swarTimeData.forEach(d => {
                        // debugger;
                        d.startTime = d.startDateTime - this.recStartDateTime;
                        d.duration = d.endDateTime - d.startDateTime;
                        d.endTime = d.startTime + d.duration;
                        // return {startTime, duration, swar: d.swar, keyIndex: d.keyIndex}
                        // return {...d, startTime, duration}
                    });
                    // console.log(this.swarTimeData);
                },
                onMidiEnabled() {
                    if (WebMidi.inputs.length < 1) {
                        console.log('No MIDI device detected.');
                        //TODO: Show this error
                        // document.body.innerHTML += "No device detected.";
                    } else {
                        WebMidi.inputs.forEach((device, index) => {
                            this.deviceId = index;
                            this.deviceName = device.name;
                        });
                    }

                    const mySynth = WebMidi.inputs[0];
                    // const mySynth = WebMidi.getInputByName("TYPE NAME HERE!")

                    mySynth.channels[1].addListener("noteoff", e => {
                        if(this.recState != 'RECORDING') return;
                        console.log('noteoff', e.note.number);
                        let keyIndex = this.keys.indexOf(e.note.identifier);
                        if (keyIndex != -1) {
                            this.swarTimeData.push({
                                duration: 0, startTime: 0, endTime: 0,     //Calcualted in the calculateSwarTimes()
                                keyIndex,
                                swar: swars[keyIndex],
                                endDateTime: new Date(),
                                startDateTime: this.pianoKeyDownInfo.dateTime
                            });
                            console.log(this.swarTimeData[this.swarTimeData.length - 1]);
                        }

                    });

                    mySynth.channels[1].addListener("noteon", e => {
                        if(this.recState != 'RECORDING') return;
                        console.log('noteon', e.note.number)
                        this.pianoKeyDownInfo = {
                            keyEvent: e,
                            dateTime: new Date()
                        };
                        // if(this.recState != 'RECORDING') return;

                        // let keyIndex = this.keys.indexOf(e.note.identifier);
                        // // console.log({index});
                        // if (keyIndex == -1) {
                        //     //this.handleKeyOperation(e.note.number);
                        // } else {
                        //     this.swarTimeData.push(keyIndex)
                        //     console.log(keyIndex);
                        //     // // this.swarPressed.push(swars[index]);
                        //     // this.swarKeyPressed(this.swars[index]);
                        // }



                        // if (!this.captureIsOn) return;
                        // let index = this.keys.indexOf(e.note.identifier);
                        // // console.log({index});
                        // if (index == -1) {
                        //     this.handleKeyOperation(e.note.number);
                        // } else {
                        //     // console.log(index, this.swars[index], this.swarsEng[index]);
                        //     // this.swarPressed.push(swars[index]);
                        //     this.swarKeyPressed(this.swars[index]);
                        // }
                    });

                    this.$options.mySynth = mySynth;

                },


            },
            created() {
                console.log('Recorder created');
                this.$options.chunks = [];
                this.$options.zip = new JSZip();
                const constraints = { audio: true };
                navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                    this.$options.mediaRecorder = new MediaRecorder(stream);
                    this.mediaRecorderCreated = true;
                    console.log('Media Recorder created');
                }, () => {
                    console.log('Error getting: navigator.mediaDevices.getUserMedia');
                });
                this.projectFileName = this.generateProjectFileName();


                WebMidi.enable().then(this.onMidiEnabled).catch(err => {
                    //TODO: Show this error
                    //this.$options.deviceName = err;
                }, true);

            },
            beforeDestroy(){
                console.log('Recorder beforeDestroy');
                this.$options.mySynth.removeListener();
            }
        })


        const Main = Vue.component('Main', {
            template: '#main-template',
            data: () => {
                return {
                    curTab: null,
                    tabTitleIndex: 1,
                    tabs: [
                        {
                            title: 'Welcome',
                            type: 'welcome'
                        }
                        // , {
                        //     title: 'Rec-1',
                        //     type: 'rec'
                        // }, {
                        //     title: 'Play-1',
                        //     type: 'play'
                        // }
                    ]
                }
            },
            methods: {
                addNewPlayer() {
                    console.log('addNewPlayer called');
                    this.tabTitleIndex++;
                    this.tabs.push({ title: 'Play-' + this.tabTitleIndex, type: 'play' });
                    this.curTab = this.tabs.length - 1;
                },
                addNewRecording() {
                    console.log('addNewRecording called');
                    this.tabTitleIndex++;
                    this.tabs.push({ title: 'Rec-' + this.tabTitleIndex, type: 'rec' });
                    this.curTab = this.tabs.length - 1;
                },
                addNewSwarEdit(swarTxt) {
                    console.log('addNewSwarEdit called: ', swarTxt);
                    this.tabTitleIndex++;
                    this.tabs.push({ title: 'SEdit-' + this.tabTitleIndex, type: 'swarEdit', swarTxt });
                    this.curTab = this.tabs.length - 1;
                },
                closeTab(tabIndex) {
                    let refId = this.tabs[tabIndex].type + '-' + tabIndex;
                    // console.log('Closing refid = ' + refId);
                    let component = this.$refs[refId];
                    // console.log(component[0]);
                    component[0].$destroy();

                    this.tabs.splice(tabIndex, 1);
                    console.log('closeTab called...');
                }
            },
            mounted() {
                this.curTab = 0;
            },
            created() {
                this.$router.app.$on('onAddNewRecording', this.addNewRecording);
                this.$router.app.$on('onAddNewPlayer', this.addNewPlayer);
                this.$router.app.$on('onAddNewSwarEdit', this.addNewSwarEdit);

                console.log('Main created');
            }
        })

        const Home = Vue.component('Home', {
            template: '#home-template',
            data: () => {
                return {
                    audio, swarTimeData, prevSwarIndex, timer, tickInterval, tickIntervalMs,
                    minSwarIndex, maxSwarIndex, swars, keyboardLine, swarLines, colors, audioDuration,
                    totalHeight, swarBarBgOpacify
                }
            },
            methods: {
                test() {
                    this.swarTimeData.forEach((d, di) => {
                        let curSwarBar = this.$refs['swar-bar-' + di][0];
                        let color = curSwarBar.dataset['bgColor'];
                        curSwarBar.style.backgroundColor = color + 'F5';
                        console.log(curSwarBar.style.backgroundColor, curSwarBar.dataset['bgColor']);
                    });

                },
                highlightSwarBar(swarTimeIndex) {
                    this.swarTimeData.forEach((d, di) => {
                        let curSwarBar = this.$refs['swar-bar-' + di][0];
                        let color = curSwarBar.dataset['bgColor'];
                        if (di == swarTimeIndex) {
                            color += 'F5';
                        } else {
                            color += this.swarBarBgOpacify;
                        }
                        // console.log(di, swarTimeIndex, color);
                        curSwarBar.style.backgroundColor = color;
                    });
                },
                onTick() {
                    let curTime = this.audio.currentTime;
                    let index = this.swarTimeData.findIndex(d => curTime >= d.timeS && curTime <= d.timeE);
                    // console.log(curTime, index);
                    if (index != -1 && index != this.prevSwarIndex) {
                        // console.log(this.swarTimeData[index], curTime, this.swarTimeData[index].time - curTime);
                        this.prevSwarIndex = index;
                        this.highlightSwarBar(index);
                        let curSwarBar = this.$refs['swar-bar-' + index][0];
                        // console.log({curSwarBar}, curSwarBar.dataset['bgColor']);
                        curSwarBar.style.backgroundColor = curSwarBar.dataset['bgColor'] + 'F5';
                    }
                },
                stopAnim() {
                    console.log('stoping naim...');
                },
                startAnim() {
                    let swarLineTable = this.$refs.swarLineTable;

                    // swarLineTable.offsetTop = this.swarLineTableOffsetTop;

                    console.log('starting naim...', this.swarLineTableOffsetTop);
                    console.log({ totalHeight: this.totalHeight, audioDuration: this.audioDuration });
                    const animation = gsap.timeline();


                    this.swarTimeData.forEach((d, di) => {
                        let curSwarBar = this.$refs['swar-bar-' + di][0];
                        let color = curSwarBar.dataset['bgColor'];
                        curSwarBar.style.backgroundColor = color + this.swarBarBgOpacify;
                    });


                    animation.set(swarLineTable, { y: 0 }).to(swarLineTable, { y: this.totalHeight * -1, ease: "linear", duration: this.audioDuration })
                },
                audioPlaying() {
                    console.log('onPlaying...');
                    this.timer = setInterval(this.onTick, this.tickInterval);
                    this.startAnim();
                },
                audioPaused() {
                    console.log('audioPaused...');
                    clearInterval(this.timer);
                    this.stopAnim();
                },
                audioEnded() {
                    console.log('audioEnded...');
                    clearInterval(this.timer);
                    this.stopAnim();
                    this.prevSwarIndex = -1;
                },
                audioSeeking(e) {
                    // console.log('audioSeeking...', this.audio.currentTime);
                    // this.onTick();
                },
                // audioLoadedData(e) {
                //     console.log(this.audio.duration)
                // },
                getClassForKeyboardSwar(kbSwar) {
                    let classNames = 'keyboard-swar ome-bhatkhande-english';
                    if (!kbSwar.swarIsUsed) classNames += ' unused-swar';
                    return classNames;
                },
                getSwarbarStyle(lineData) {
                    let style = '';
                    if (lineData.swar != null) {
                        //Opacity suffix to hash colors: 00, 01, 99, 9D, 1D, CC, E4, F5
                        style = 'height: ' + lineData.height + 'px; background-color: ' + lineData.color + this.swarBarBgOpacify + ';'
                    }
                    return style;
                }
            },
            mounted() {
                this.audio = this.$refs['mainAudio'];
                this.audio.currentTime = 24 * 60 * 60;
                // console.log(this.audio);
                this.audio.addEventListener('timeupdate', setDuration = () => {
                    this.audioDuration = this.audio.duration;
                    console.log('duration=', this.audio.duration);
                    this.audio.currentTime = 0;
                    this.audio.removeEventListener('timeupdate', setDuration)
                })
                this.audio.addEventListener('playing', this.audioPlaying);
                this.audio.addEventListener('pause', this.audioPaused);
                this.audio.addEventListener('ended', this.audioEnded);
                this.audio.addEventListener('seeking', this.audioSeeking);
                // this.audio.addEventListener('loadeddata', this.audioLoadedData);

                // this.audio.addEventListener("durationchange", function (e) {
                //     if (this.duration != Infinity) {
                //         var duration = this.duration
                //         _player.remove();
                //         next(duration);
                //     };
                // }, false);

                let swarLineTable = this.$refs.swarLineTable;
                // this.swarLineTableOffsetTop = swarLineTable.offsetTop;
                console.log(swarLineTable);


            }
        })

        function getMinMaxSwar(swarTimeData) {
            //This funciton also adds swarIndex to each swarTimeData
            let indexes = swarTimeData.map(d => {
                d.swarIndex = swars.indexOf(d.swar);
                return d.swarIndex;
            });
            // console.log(indexes);
            return { minSwarIndex: Math.min.apply(Math, indexes), maxSwarIndex: Math.max.apply(Math, indexes) };
        }

        function getVizLines(swarTimeData) {

            let keyboardLine = [];
            for (let i = minSwarIndex; i <= maxSwarIndex; i++) {
                let swarIsUsed = swarTimeData.findIndex(d => d.swar == swars[i]) == -1 ? false : true;
                keyboardLine.push({
                    swar: swars[i], swarIsUsed
                });
                // console.log({ swarIsUsed })
            }

            let swarLines = [];
            let totalHeight = 0;
            swarTimeData.forEach((d, di) => {
                let swarData = [];
                for (let i = minSwarIndex; i <= maxSwarIndex; i++) {
                    let swar = null;
                    let height = 0;
                    let color = '';
                    let swarTimeIndex = -1;
                    if (i == d.swarIndex) {
                        swar = d.swar;
                        height = (d.timeE - d.timeS) * swarBarHeightMultiplier;
                        color = getColorOfSwar(swar);
                        totalHeight += height - 0.5;
                        swarTimeIndex = di;
                    }
                    swarData.push({
                        swar, height, color, totalHeight, swarTimeIndex
                    })
                }
                swarLines.push(swarData);
            });
            // console.log({ keyboardLine, swarLines });
            // console.log({ totalHeight });
            return { keyboardLine, swarLines, totalHeight };
        }

        function getColorOfSwar(swar) {
            let index = swars.indexOf(swar);
            let colorIndex = index - minSwarIndex;
            return colors[colorIndex];
        }


        const Welcome = Vue.component('Welcome', {
            template: '#welcome-template',
            data() {
                return {
                    bodyHTML: 'Loading...'
                }
            },
            methods: {
            },
            async mounted() {
                // setTimeout(() => {
                //     this.bodyHTML = marked.parse('# Marked in the browser\n\nRendered by **marked**.');
                // }, 2000);
                let welcomeMDtxt = await fetch('README.md').then(res => res.text());
                console.log(welcomeMDtxt);
                this.bodyHTML = marked.parse(welcomeMDtxt);
            },
            created() {
                console.log('Welcome created');
            }
        })




        // const Bar = Vue.component('Bar-Page', {
        //     template: '#bar-template',
        //     data() {
        //         return {
        //             state: store.state
        //         }
        //     },
        //     methods: {
        //     },
        //     created() {
        //         console.log('Bar created');
        //     }
        // })

        function initVue() {

            const routes = [
                { path: '/', component: Main },
                // { path: '/recorder', component: Recorder },
                // { path: '/welcome', component: Welcome },
                // { path: '/home', component: Home }
            ]

            const router = new VueRouter({
                routes // short for `routes: routes`
            })

            vm = new Vue({
                el: '#app',
                router,
                vuetify: new Vuetify(),
                methods: {
                    addNewRecording() {
                        console.log('Emitting addNewRecording...');
                        this.$router.app.$emit('onAddNewRecording');
                    },
                    addNewPlayer() {
                        console.log('Emitting addNewPlayer...');
                        this.$router.app.$emit('onAddNewPlayer');
                    },
                    addNewSwarEdit() {
                        console.log('Emitting addNewSwarEdit...');
                        this.$router.app.$emit('onAddNewSwarEdit', '');
                    }
                },
                mounted() {
                    // this.addNewPlayer();
                    // this.addNewSwarEdit();
                }
            })
        }

        function loadReadmeInWelcomeTemplate() {
            // document.getElementById('welcome-template-body').innerHTML =
            //     marked.parse('# Marked in the browser\n\nRendered by **marked**.');
        }


        function init() {
            // loadReadmeInWelcomeTemplate();
            initVue();
            // createPDF();
        }

        init();


        function XXcreatePDF() {

            // const doc = new jspdf.jsPDF({
            //     orientation: "landscape",
            //     unit: "in",
            //     format: [4, 2]
            // });
            // doc.text("Hello world!", 1, 1);
            // doc.save("two-by-four.pdf");


            // var doc = new jspdf.jsPDF();
            // doc.html(document.body, {
            //     callback: function (doc) {
            //         doc.save();
            //     },
            //     x: 10,
            //     y: 10
            // });

            // const myFont = ... // load the *.ttf font file as binary string
            // add the font to jsPDF
            // doc.addFileToVFS("MyFont.ttf", myFont);
            // doc.addFont("MyFont.ttf", "MyFont", "normal");
            // doc.setFont("MyFont");

        }



        // recordAudio();

        function XXrecordAudio() {
            const constraints = { audio: true };
            let mainAudio = document.getElementById('mainAudio');
            navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                let chunks = [];
                const mediaRecorder = new MediaRecorder(stream);
                console.log('Starting recording...for 4 sec...');
                mediaRecorder.start();
                setTimeout(() => {
                    console.log('Stopping recording...');
                    mediaRecorder.stop();
                }, 4000);

                mediaRecorder.onstop = async (e) => {
                    const blob = new Blob(chunks, { 'type': 'audio/ogg; codecs=opus' });
                    chunks = [];
                    const audioURL = window.URL.createObjectURL(blob);
                    mainAudio.src = audioURL;
                }
                mediaRecorder.ondataavailable = function (e) {
                    console.log('Getting chunks...')
                    chunks.push(e.data);
                }
            }, () => {
                console.log('Error getting: navigator.mediaDevices.getUserMedia');
            });
        }

        function XXinitDownloadJSONFile(storageOb) {
            //For text file use  'data:text/plain;charset=utf-8,'
            var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(storageObj));
            var dlAnchorElem = document.getElementById('downloadAnchorElem');
            dlAnchorElem.setAttribute("href", dataStr);
            dlAnchorElem.setAttribute("download", "scene.json");
            dlAnchorElem.click();
        }

    </script>
</body>

</html>